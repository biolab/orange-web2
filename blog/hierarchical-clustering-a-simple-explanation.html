<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>My new cool app</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/4ac7ed34d61ef456.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4ac7ed34d61ef456.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-d38be8d96a62f950.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-9f90a364d66949ce.js" defer=""></script><script src="/_next/static/chunks/pages/_app-8cfbd06f8ddd0b49.js" defer=""></script><script src="/_next/static/chunks/675-262430aa11afdf01.js" defer=""></script><script src="/_next/static/chunks/9-9d15d34c7affe00b.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-ba4a3f289f8ef3c5.js" defer=""></script><script src="/_next/static/t3FkTJiCx_jp9wzVJgeAY/_buildManifest.js" defer=""></script><script src="/_next/static/t3FkTJiCx_jp9wzVJgeAY/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.6">.iBQlkL{background:coral;height:60px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}/*!sc*/
@media (max-width:920px){.iBQlkL ul{display:none;}}/*!sc*/
data-styled.g1[id="sc-7295e4c-0"]{content:"iBQlkL,"}/*!sc*/
.bDMZDz{display:none;font-size:22px;margin-left:auto;}/*!sc*/
@media (max-width:920px){.bDMZDz{display:block;}}/*!sc*/
data-styled.g2[id="sc-7295e4c-1"]{content:"bDMZDz,"}/*!sc*/
html,body{height:100%;margin:0;}/*!sc*/
body{background:#fff;}/*!sc*/
html{box-sizing:border-box;font-size:16px;}/*!sc*/
*,*:before,*:after{box-sizing:inherit;}/*!sc*/
body,h1,h2,h3,h4,h5,h6,p,ol,ul{margin:0;padding:0;font-weight:normal;}/*!sc*/
ol,ul{list-style:none;}/*!sc*/
img,video{max-width:100%;height:auto;}/*!sc*/
.lg-container .lg-backdrop.in{opacity:0.75;}/*!sc*/
.lg-container .lg-toolbar.lg-group,.lg-container .lg-outer .lg-thumb-outer{background:rgba(0,0,0,0.45);}/*!sc*/
data-styled.g3[id="sc-global-cqyaiF1"]{content:"sc-global-cqyaiF1,"}/*!sc*/
.cGDPDa{max-width:800px;margin:0 auto;}/*!sc*/
data-styled.g6[id="sc-f0e62130-0"]{content:"cGDPDa,"}/*!sc*/
</style></head><body><div id="__next"><nav class="sc-7295e4c-0 iBQlkL"><ul><a href="/blog">Blog</a></ul><button class="sc-7295e4c-1 bDMZDz">X</button></nav><main><div class="sc-f0e62130-0 cGDPDa"><h1>Hierarchical Clustering: A Simple Explanation</h1><div class="lg-react-element "><p>One of the key techniques of exploratory data mining is clustering – separating instances into distinct groups based on some measure of similarity. We can estimate the similarity between two data instances through euclidean (pythagorean), manhattan (sum of absolute differences between coordinates) and mahalanobis distance (distance from the mean by standard deviation), or, say, through Pearson correlation or Spearman correlation.</p>
<p>Our main goal when clustering data is to get groups of data instances where:</p>
<ul>
<li>each group (Ci) is a a subset of the training data (U): Ci ⊂ U</li>
<li>an intersection of all the sets is an empty set: Ci ∩ Cj = 0</li>
<li>a union of all groups equals the train data: Ci ∪ Cj = U</li>
</ul>
<p>This would be ideal. But we rarely get the data, where separation is so clear. One of the easiest techniques to cluster the data is hierarchical clustering. First, we take an instance from, say, 2D plot. Now we want to find its nearest neighbor. Nearest neighbor of course depends on the measure of distance we choose, but let’s go with euclidean for now as it is the easiest to visualize.
<a href="/blog/2015-12-hierarchical-clustering-a-simple-explanation/__webp-images__/hier-clust-blog-compare1.webp" data-gallery="true"><img alt="" srcSet="/blog/2015-12-hierarchical-clustering-a-simple-explanation/__webp-images__/hier-clust-blog-compare1.webp 1x, /blog/2015-12-hierarchical-clustering-a-simple-explanation/__webp-images__/hier-clust-blog-compare1.webp 2x" src="/blog/2015-12-hierarchical-clustering-a-simple-explanation/__webp-images__/hier-clust-blog-compare1.webp" width="1200" height="540" decoding="async" data-nimg="1" loading="lazy" style="color:transparent"/></a>
First steps of hierarchical clustering.</p>
<p>Euclidean distance is calculated as:</p>
<a href="https://upload.wikimedia.org/wikipedia/commons/thumb/5/55/Euclidean_distance_2d.svg/220px-Euclidean_distance_2d.svg.png" data-gallery="true"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/55/Euclidean_distance_2d.svg/220px-Euclidean_distance_2d.svg.png" alt=""/></a>
<p>Naturally, the shorter the distance the more similar the two instances are. In the beginning, all instances are in their own particular clusters. Then we seek for the closest instances of every instance in the plot. We pin down the closest instance and make a cluster of the original and the closest instance. Now we repeat the process again. What is the closest instances to our new cluster –&gt; add it to the cluster –&gt; find the closest instance. We repeat this procedure until all the instances are grouped in one single cluster.</p>
<p>We can write this down also in a form of a pseudocode:</p>
<pre><code>	every instance is in its own cluster

	repeat until instances are all in one group:

	    find the closest instances to the group (distance has to be minimum)

	    join closest instances with the group
</code></pre>
<a href="/blog/2015-12-hierarchical-clustering-a-simple-explanation/__webp-images__/hier-clust-blog6.webp" data-gallery="true"><img alt="" srcSet="/blog/2015-12-hierarchical-clustering-a-simple-explanation/__webp-images__/hier-clust-blog6.webp 1x, /blog/2015-12-hierarchical-clustering-a-simple-explanation/__webp-images__/hier-clust-blog6.webp 2x" src="/blog/2015-12-hierarchical-clustering-a-simple-explanation/__webp-images__/hier-clust-blog6.webp" width="876" height="749" decoding="async" data-nimg="1" loading="lazy" style="color:transparent"/></a>
<p>Visualization of this procedure is called a dendrogram, which is what Hierarchical clustering widget displays in Orange.</p>
<a href="/blog/2015-12-hierarchical-clustering-a-simple-explanation/__webp-images__/hier-clust-blog-compare21.webp" data-gallery="true"><img alt="" srcSet="/blog/2015-12-hierarchical-clustering-a-simple-explanation/__webp-images__/hier-clust-blog-compare21.webp 1x, /blog/2015-12-hierarchical-clustering-a-simple-explanation/__webp-images__/hier-clust-blog-compare21.webp 2x" src="/blog/2015-12-hierarchical-clustering-a-simple-explanation/__webp-images__/hier-clust-blog-compare21.webp" width="1200" height="360" decoding="async" data-nimg="1" loading="lazy" style="color:transparent"/></a>
<p>Single, complete and average linkage.</p>
<p>Another thing to consider is the distance between instances when we have already two or more instances in a cluster. Do we go with the closest instance in a cluster or to the furthest one?</p>
<ul>
<li>Picture A shows the distances to the closest instance – single linkage.</li>
<li>Picture B shows the distance to the furthest instance – complete linkage.</li>
<li>Picture C shows the average of all distances in a cluster to the instance – average linkage.</li>
</ul>
<p><a href="/blog/2015-12-hierarchical-clustering-a-simple-explanation/__webp-images__/single-vs-complete.webp" data-gallery="true"><img alt="" srcSet="/blog/2015-12-hierarchical-clustering-a-simple-explanation/__webp-images__/single-vs-complete.webp 1x, /blog/2015-12-hierarchical-clustering-a-simple-explanation/__webp-images__/single-vs-complete.webp 2x" src="/blog/2015-12-hierarchical-clustering-a-simple-explanation/__webp-images__/single-vs-complete.webp" width="1200" height="480" decoding="async" data-nimg="1" loading="lazy" style="color:transparent"/></a>
Single vs complete linkage.</p>
<p>The downside of single linkage is, even by intuition, creating elongated, stretched clusters. Instances at the top part of the red C are in fact quite different from the lower part of the red C. Complete linkage does much better here as it centers clustering nicely. However, the downside of complete linkage is taking outliers too much into consideration. Naturally, each approach has its own pros and cons and it’s good to know how they work in order to use them correctly. One extra hint: single linkage works great for image recognition, exactly because it can follow the curve.</p>
<p>There’s a lot more we could say about hierarchical clustering, but to sum it up, let’s state pros and cons of this method:</p>
<ul>
<li>pros: sums up the data, good for small data sets</li>
<li>cons: computationally demanding, fails on larger sets</li>
</ul></div></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"frontmatter":{"author":"AJDA","date":"2015-12-02 13:37:49+00:00","draft":false,"title":"Hierarchical Clustering: A Simple Explanation","type":"blog","blog":["clustering","education","plot"]},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    ul: \"ul\",\n    li: \"li\",\n    img: \"img\",\n    pre: \"pre\",\n    code: \"code\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"One of the key techniques of exploratory data mining is clustering – separating instances into distinct groups based on some measure of similarity. We can estimate the similarity between two data instances through euclidean (pythagorean), manhattan (sum of absolute differences between coordinates) and mahalanobis distance (distance from the mean by standard deviation), or, say, through Pearson correlation or Spearman correlation.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Our main goal when clustering data is to get groups of data instances where:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"each group (Ci) is a a subset of the training data (U): Ci ⊂ U\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"an intersection of all the sets is an empty set: Ci ∩ Cj = 0\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"a union of all groups equals the train data: Ci ∪ Cj = U\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This would be ideal. But we rarely get the data, where separation is so clear. One of the easiest techniques to cluster the data is hierarchical clustering. First, we take an instance from, say, 2D plot. Now we want to find its nearest neighbor. Nearest neighbor of course depends on the measure of distance we choose, but let’s go with euclidean for now as it is the easiest to visualize.\\n\", _jsx(_components.img, {\n        src: \"/blog/2015-12-hierarchical-clustering-a-simple-explanation/__webp-images__/hier-clust-blog-compare1.webp\",\n        alt: \"\",\n        width: \"1200\",\n        height: \"540\"\n      }), \"\\nFirst steps of hierarchical clustering.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Euclidean distance is calculated as:\"\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"https://upload.wikimedia.org/wikipedia/commons/thumb/5/55/Euclidean_distance_2d.svg/220px-Euclidean_distance_2d.svg.png\",\n      alt: \"\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Naturally, the shorter the distance the more similar the two instances are. In the beginning, all instances are in their own particular clusters. Then we seek for the closest instances of every instance in the plot. We pin down the closest instance and make a cluster of the original and the closest instance. Now we repeat the process again. What is the closest instances to our new cluster –\u003e add it to the cluster –\u003e find the closest instance. We repeat this procedure until all the instances are grouped in one single cluster.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We can write this down also in a form of a pseudocode:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"\\tevery instance is in its own cluster\\n\\n\\trepeat until instances are all in one group:\\n\\n\\t    find the closest instances to the group (distance has to be minimum)\\n\\n\\t    join closest instances with the group\\n\"\n      })\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/blog/2015-12-hierarchical-clustering-a-simple-explanation/__webp-images__/hier-clust-blog6.webp\",\n      alt: \"\",\n      width: \"876\",\n      height: \"749\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Visualization of this procedure is called a dendrogram, which is what Hierarchical clustering widget displays in Orange.\"\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/blog/2015-12-hierarchical-clustering-a-simple-explanation/__webp-images__/hier-clust-blog-compare21.webp\",\n      alt: \"\",\n      width: \"1200\",\n      height: \"360\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Single, complete and average linkage.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Another thing to consider is the distance between instances when we have already two or more instances in a cluster. Do we go with the closest instance in a cluster or to the furthest one?\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Picture A shows the distances to the closest instance – single linkage.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Picture B shows the distance to the furthest instance – complete linkage.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Picture C shows the average of all distances in a cluster to the instance – average linkage.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.img, {\n        src: \"/blog/2015-12-hierarchical-clustering-a-simple-explanation/__webp-images__/single-vs-complete.webp\",\n        alt: \"\",\n        width: \"1200\",\n        height: \"480\"\n      }), \"\\nSingle vs complete linkage.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The downside of single linkage is, even by intuition, creating elongated, stretched clusters. Instances at the top part of the red C are in fact quite different from the lower part of the red C. Complete linkage does much better here as it centers clustering nicely. However, the downside of complete linkage is taking outliers too much into consideration. Naturally, each approach has its own pros and cons and it’s good to know how they work in order to use them correctly. One extra hint: single linkage works great for image recognition, exactly because it can follow the curve.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"There’s a lot more we could say about hierarchical clustering, but to sum it up, let’s state pros and cons of this method:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"pros: sums up the data, good for small data sets\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"cons: computationally demanding, fails on larger sets\"\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"hierarchical-clustering-a-simple-explanation"},"buildId":"t3FkTJiCx_jp9wzVJgeAY","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>