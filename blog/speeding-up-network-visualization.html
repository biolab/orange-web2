<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-45fae5f2ec2ec297.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-abafce5311b78c60.js" defer=""></script><script src="/_next/static/chunks/pages/_app-463eea64dd46fd78.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-9737114052c0c44f.js" defer=""></script><script src="/_next/static/Hu_fAq4nVJS-wfnPiRc1Q/_buildManifest.js" defer=""></script><script src="/_next/static/Hu_fAq4nVJS-wfnPiRc1Q/_ssgManifest.js" defer=""></script></head><body><div id="__next"><nav class="navbar__Nav-sc-q11qw3-0 hZTkcw"><ul><a href="/blog">Blog</a></ul><button class="navbar__Burger-sc-q11qw3-1 cGMLJw">X</button></nav><main><div class="slug__Wrapper-sc-1xtdpf8-0 cHTstd"><h1>Speeding Up Network Visualization</h1><p>The Orange3 Network add-on contains a convenient Network Explorer widget for network visualization. Orange uses an iterative force-directed method (a variation of the Fruchterman-Reingold Algorithm) to layout the nodes on the 2D plane.</p>
<p><img src="/blog/2017-12-speeding-up-network-visualization/network-schema.png" alt=""/></p>
<p>The goal of force-directed methods is to draw connected nodes close to each other as if the edges that connect the nodes were acting as springs. We also don&#x27;t want all nodes crowded in a single point, but would rather have them spaced evenly. This is achieved by simulating a repulsive force, which decreases with the distance between nodes.</p>
<p>There are two types of forces acting on each node:</p>
<ul>
<li>the attractive force towards connected adjacent nodes,</li>
<li>the repulsive force that is directed away from all other nodes.</li>
</ul>
<p>We could say that such network visualization as a whole is rather repulsive. Let&#x27;s take for example the <em>lastfm.net</em> network that comes with Orange&#x27;s network add-on and which has around 1.000 nodes and 4.000 edges. In every iteration, we have to consider 4.000 attractive forces and 1.000.000 repulsive forces for every of 1.000 times 1.000 edges. It takes about 100 iterations to get a decent network layout. That&#x27;s a lot of repulsions, and you&#x27;ll have to wait a while before you get the final layout.</p>
<p>Fortunately, we found a simple hack to speed things up. When computing the repulsive force acting on some node, we only consider a 10% sample of other nodes to obtain an estimate. We multiply the result by 10 and hope it&#x27;s not off by too much. By choosing a different sample in every iteration we also avoid favoring some set of nodes.</p>
<p>The left layout is obtained without sampling while the right one uses a 10% sampling. The results are pretty similar, but the sampling method is 10 times faster!</p>
<p><img src="/blog/2017-12-speeding-up-network-visualization/layout-compare.png" alt=""/></p>
<p>Now that the computation is fast enough, it is time to also speed-up the drawing. But that&#x27;s a task for 2018.</p></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"frontmatter":{"author":"THOCEVAR","date":"2017-12-23 17:05:52+00:00","draft":false,"title":"Speeding Up Network Visualization","type":"blog","blog":["addons","network","visualization"]},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    ul: \"ul\",\n    li: \"li\",\n    em: \"em\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"The Orange3 Network add-on contains a convenient Network Explorer widget for network visualization. Orange uses an iterative force-directed method (a variation of the Fruchterman-Reingold Algorithm) to layout the nodes on the 2D plane.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/blog/2017-12-speeding-up-network-visualization/network-schema.png\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The goal of force-directed methods is to draw connected nodes close to each other as if the edges that connect the nodes were acting as springs. We also don't want all nodes crowded in a single point, but would rather have them spaced evenly. This is achieved by simulating a repulsive force, which decreases with the distance between nodes.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"There are two types of forces acting on each node:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"the attractive force towards connected adjacent nodes,\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"the repulsive force that is directed away from all other nodes.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"We could say that such network visualization as a whole is rather repulsive. Let's take for example the \", _jsx(_components.em, {\n        children: \"lastfm.net\"\n      }), \" network that comes with Orange's network add-on and which has around 1.000 nodes and 4.000 edges. In every iteration, we have to consider 4.000 attractive forces and 1.000.000 repulsive forces for every of 1.000 times 1.000 edges. It takes about 100 iterations to get a decent network layout. That's a lot of repulsions, and you'll have to wait a while before you get the final layout.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Fortunately, we found a simple hack to speed things up. When computing the repulsive force acting on some node, we only consider a 10% sample of other nodes to obtain an estimate. We multiply the result by 10 and hope it's not off by too much. By choosing a different sample in every iteration we also avoid favoring some set of nodes.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The left layout is obtained without sampling while the right one uses a 10% sampling. The results are pretty similar, but the sampling method is 10 times faster!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/blog/2017-12-speeding-up-network-visualization/layout-compare.png\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now that the computation is fast enough, it is time to also speed-up the drawing. But that's a task for 2018.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"speeding-up-network-visualization"},"buildId":"Hu_fAq4nVJS-wfnPiRc1Q","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>