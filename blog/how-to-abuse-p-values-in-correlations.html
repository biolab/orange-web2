<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-45fae5f2ec2ec297.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-abafce5311b78c60.js" defer=""></script><script src="/_next/static/chunks/pages/_app-463eea64dd46fd78.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-9737114052c0c44f.js" defer=""></script><script src="/_next/static/Pq4MTEXwxi3akD3CFvrRB/_buildManifest.js" defer=""></script><script src="/_next/static/Pq4MTEXwxi3akD3CFvrRB/_ssgManifest.js" defer=""></script></head><body><div id="__next"><nav class="navbar__Nav-sc-q11qw3-0 hZTkcw"><ul><a href="/blog">Blog</a></ul><button class="navbar__Burger-sc-q11qw3-1 cGMLJw">X</button></nav><main><div class="slug__Wrapper-sc-1xtdpf8-0 cHTstd"><h1>How to Abuse p-Values in Correlations</h1><p>In a parallel universe, not so far from ours, Orange’s Correlation widget looks like this.</p>
<p>\</p>
<img src="/blog/2019-1-how-to-abuse-p-values-in-correlations/correlations-p-values-1.png"/>
<p><br/>
<!-- -->\</p>
<p>Quite similar to ours, except that this one shows p-values instead of correlation coefficients. Which is actually better, isn’t it? I mean, we have all attended Statistics 101, and we know that you can never trust correlation coefficients without looking at p-values to check that these correlations are real, right? So why on Earth doesn’t Orange show them?</p>
<p>First a side note. It was Christmas not long ago. Let’s call a ceasefire on the frequentist vs. Bayesian war. Let us, for Christ’s sake, pretend, pardon, agree that null-hypothesis testing is not wrong per se.</p>
<p>The mantra of null-hypothesis significance testing goes like this:</p>
<ol>
<li>Form hypothesis.</li>
<li>Collect data.</li>
<li>Test hypothesis.</li>
</ol>
<p>In contrast, the parallel-universe Correlation widget is (ab)used like this:</p>
<ol>
<li>Collect data.</li>
<li>Test all possible hypotheses.</li>
<li>Cherry pick those that are confirmed.</li>
</ol>
<p>This is like the <a href="https://en.wikipedia.org/wiki/Texas_sharpshooter_fallacy" target="_blank">Texas sharpshooter</a> who fires first and then draws targets around the shots. You should never formulate hypothesis based on some data and then use this same data to prove it. Because it usually (surprise!) works.</p>
<p>\</p>
<img src="/blog/2019-1-how-to-abuse-p-values-in-correlations/TexasSharpShooter.png"/>
<p><br/>
<!-- -->\</p>
<p>Back to the above snapshot. It shows correlations between 100 vegetables based on 100 different measurements (Ca and Mg content, their consumption in Finland, number of mentions in Star Trek DS9 series, likelihood of finding it on the Mars, and so forth). In other words, it’s all made it up. Just a 100×100 matrix of random numbers with column labels from the simple Wikipedia <a href="https://simple.wikipedia.org/wiki/List_of_vegetables" target="_blank">list of vegetables</a>. Yet the similarity between <a href="https://en.wikipedia.org/wiki/Mung_bean" target="_blank">mung bean</a> and <a href="https://en.wikipedia.org/wiki/Jerusalem_artichoke" target="_blank">sunchokes</a> surely cannot be dismissed (p &lt; 0.001). Those who like bell pepper should try cilantro, too, because it’s basically one and the same thing (p = 0.001). And I honestly can’t tell black bean from wasabi (p = 0.001).</p>
<p>Here are the p-values for the top 100 most correlated pairs.</p>
<p>import numpy as np
import scipy as sp
a = np.random.random((100, 100))
sorted(stats.pearsonr(a[i], a[j])[1] for i in range(100) for j in range(i))[:100]
[0.0002774329730584203, 0.0004158786523819104, 0.0005008536192579852,
0.0007211022164265075, 0.0008268675086438253, 0.0010265740674904762,
(...91 values omitted to reduce the nonsense)
0.01844720610938738, 0.018465602922746942, 0.018662079618069056]
First 100 correlations are highly significant.</p>
<p>To learn a lesson we may have failed to grasp at the NHST 101 class, consider that there are 100 * 99 / 2 pairs. What is the significance of the pair at 5-th percentile?</p>
<p>correlations = sorted(stats.pearsonr(a[i], a[j])[1] for i in range(100) for j in range(i))
npairs = 100 * 99 / 2
print(correlations[int(pairs * 0.05)]
0.0496868751692227</p>
<p>Roughly 0.05. This is exactly what should have happened, because:</p>
<p>correlations[int(npairs * 0.10)]
0.10004180592217532
correlations[int(npairs * 0.15)]
0.15236602574520097
correlations[int(npairs * 0.30)]
0.3026816170584785
This proves only that p-values for the Pearson correlation coefficient are well calibrated (and that <a href="https://en.wikipedia.org/wiki/Mersenne_Twister" target="_blank">Mersenne twister</a> that is used to generate random numbers in numpy works well). In theory, the p-value for a certain statistics (like Pearson’s r) is the probability of getting such or even more extreme value if the null-hypothesis (of no correlation, in our case) is actually true. 5 % of random hypotheses should have a p-value below 0.05, 10 % a value below 10, and 23 % a value below 23.</p>
<p>Imagine what they can do with the Correlations widget in the parallel universe! They compute correlations between all pairs, print out the first 5 % of them and start writing a paper without bothering to look at p-values at all. They know they should be statistically significant even if the data is random.</p>
<p>Which is precisely the reason why our widget must not compute p-values: because people would use it for Texas sharpshooting. P-values make sense only in the context of the proper NHST procedure (still pretending for the sake of Christmas ceasefire). They cannot be computed using the data on which they were found.</p>
<p>If so, why do we have the Correlation widget at all if it’s results are unpublishable? We can use it to find highly correlated pairs in a data sample. But we can’t just attach p-values to them and publish them. By finding these pairs (with assistance of Correlation widget) we just formulate hypotheses. This is only step 1 of the enshrined NHST procedure. We can’t skip the other two: the next step is to collect some new data (existing data won’t do!) and then use it to test the hypotheses (step 3).</p>
<p>Following this procedure doesn’t save us from <a href="https://en.wikipedia.org/wiki/Data_dredging" target="_blank">data dredging</a>. There are still plenty of ways to cheat. It is the most tempting to select the first 100 most correlated pairs (or, actually, any 100 pairs), (re)compute correlations on some new data and publish the top 5 % of these pairs. The official solution for this is a patchwork of various corrections for multiple hypotheses testing, but… Well, they don’t work, but we should say no more here. You know, Christmas ceasefire.</p></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"frontmatter":{"author":"Ajda Pretnar","date":"2019-01-04","draft":false,"title":"How to Abuse p-Values in Correlations","type":"blog","thumbImage":"correlations.png","image":"","blog":["correlations","NHTS","null hypothesis","p-value","statistics"],"shortExcerpt":"Why doesn't Orange show p-values for correlations coefficients? To save you from data dredging and Texas sharpshooter fallacy...","longExcerpt":"We have all attended Statistics 101, and we know that you can never trust correlation coefficients without looking at p-values to check that these correlations are real, right? So why on Earth doesn’t Orange show them?"},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    br: \"br\",\n    ol: \"ol\",\n    li: \"li\"\n  }, _provideComponents(), props.components), {Figure, LinkNew} = _components;\n  if (!Figure) _missingMdxReference(\"Figure\", true);\n  if (!LinkNew) _missingMdxReference(\"LinkNew\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"In a parallel universe, not so far from ours, Orange’s Correlation widget looks like this.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"\\\\\"\n    }), \"\\n\", _jsx(Figure, {\n      src: \"/blog/2019-1-how-to-abuse-p-values-in-correlations/correlations-p-values-1.png\",\n      width: \"40%\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.br, {}), \"\\n\", \"\\\\\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Quite similar to ours, except that this one shows p-values instead of correlation coefficients. Which is actually better, isn’t it? I mean, we have all attended Statistics 101, and we know that you can never trust correlation coefficients without looking at p-values to check that these correlations are real, right? So why on Earth doesn’t Orange show them?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"First a side note. It was Christmas not long ago. Let’s call a ceasefire on the frequentist vs. Bayesian war. Let us, for Christ’s sake, pretend, pardon, agree that null-hypothesis testing is not wrong per se.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The mantra of null-hypothesis significance testing goes like this:\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Form hypothesis.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Collect data.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Test hypothesis.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In contrast, the parallel-universe Correlation widget is (ab)used like this:\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Collect data.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Test all possible hypotheses.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Cherry pick those that are confirmed.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This is like the \", _jsx(LinkNew, {\n        url: \"https://en.wikipedia.org/wiki/Texas_sharpshooter_fallacy\",\n        name: \"Texas sharpshooter\"\n      }), \" who fires first and then draws targets around the shots. You should never formulate hypothesis based on some data and then use this same data to prove it. Because it usually (surprise!) works.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"\\\\\"\n    }), \"\\n\", _jsx(Figure, {\n      src: \"/blog/2019-1-how-to-abuse-p-values-in-correlations/TexasSharpShooter.png\",\n      width: \"50%\",\n      caption: \"Illustration by Dirk-Jan Hoek (CC-BY).\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.br, {}), \"\\n\", \"\\\\\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Back to the above snapshot. It shows correlations between 100 vegetables based on 100 different measurements (Ca and Mg content, their consumption in Finland, number of mentions in Star Trek DS9 series, likelihood of finding it on the Mars, and so forth). In other words, it’s all made it up. Just a 100×100 matrix of random numbers with column labels from the simple Wikipedia \", _jsx(LinkNew, {\n        url: \"https://simple.wikipedia.org/wiki/List_of_vegetables\",\n        name: \"list of vegetables\"\n      }), \". Yet the similarity between \", _jsx(LinkNew, {\n        url: \"https://en.wikipedia.org/wiki/Mung_bean\",\n        name: \"mung bean\"\n      }), \" and \", _jsx(LinkNew, {\n        url: \"https://en.wikipedia.org/wiki/Jerusalem_artichoke\",\n        name: \"sunchokes\"\n      }), \" surely cannot be dismissed (p \u003c 0.001). Those who like bell pepper should try cilantro, too, because it’s basically one and the same thing (p = 0.001). And I honestly can’t tell black bean from wasabi (p = 0.001).\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Here are the p-values for the top 100 most correlated pairs.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"import numpy as np\\nimport scipy as sp\\na = np.random.random((100, 100))\\nsorted(stats.pearsonr(a[i], a[j])[1] for i in range(100) for j in range(i))[:100]\\n[0.0002774329730584203, 0.0004158786523819104, 0.0005008536192579852,\\n0.0007211022164265075, 0.0008268675086438253, 0.0010265740674904762,\\n(...91 values omitted to reduce the nonsense)\\n0.01844720610938738, 0.018465602922746942, 0.018662079618069056]\\nFirst 100 correlations are highly significant.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To learn a lesson we may have failed to grasp at the NHST 101 class, consider that there are 100 * 99 / 2 pairs. What is the significance of the pair at 5-th percentile?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"correlations = sorted(stats.pearsonr(a[i], a[j])[1] for i in range(100) for j in range(i))\\nnpairs = 100 * 99 / 2\\nprint(correlations[int(pairs * 0.05)]\\n0.0496868751692227\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Roughly 0.05. This is exactly what should have happened, because:\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"correlations[int(npairs * 0.10)]\\n0.10004180592217532\\ncorrelations[int(npairs * 0.15)]\\n0.15236602574520097\\ncorrelations[int(npairs * 0.30)]\\n0.3026816170584785\\nThis proves only that p-values for the Pearson correlation coefficient are well calibrated (and that \", _jsx(LinkNew, {\n        url: \"https://en.wikipedia.org/wiki/Mersenne_Twister\",\n        name: \"Mersenne twister\"\n      }), \" that is used to generate random numbers in numpy works well). In theory, the p-value for a certain statistics (like Pearson’s r) is the probability of getting such or even more extreme value if the null-hypothesis (of no correlation, in our case) is actually true. 5 % of random hypotheses should have a p-value below 0.05, 10 % a value below 10, and 23 % a value below 23.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Imagine what they can do with the Correlations widget in the parallel universe! They compute correlations between all pairs, print out the first 5 % of them and start writing a paper without bothering to look at p-values at all. They know they should be statistically significant even if the data is random.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Which is precisely the reason why our widget must not compute p-values: because people would use it for Texas sharpshooting. P-values make sense only in the context of the proper NHST procedure (still pretending for the sake of Christmas ceasefire). They cannot be computed using the data on which they were found.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If so, why do we have the Correlation widget at all if it’s results are unpublishable? We can use it to find highly correlated pairs in a data sample. But we can’t just attach p-values to them and publish them. By finding these pairs (with assistance of Correlation widget) we just formulate hypotheses. This is only step 1 of the enshrined NHST procedure. We can’t skip the other two: the next step is to collect some new data (existing data won’t do!) and then use it to test the hypotheses (step 3).\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Following this procedure doesn’t save us from \", _jsx(LinkNew, {\n        url: \"https://en.wikipedia.org/wiki/Data_dredging\",\n        name: \"data dredging\"\n      }), \". There are still plenty of ways to cheat. It is the most tempting to select the first 100 most correlated pairs (or, actually, any 100 pairs), (re)compute correlations on some new data and publish the top 5 % of these pairs. The official solution for this is a patchwork of various corrections for multiple hypotheses testing, but… Well, they don’t work, but we should say no more here. You know, Christmas ceasefire.\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"how-to-abuse-p-values-in-correlations"},"buildId":"Pq4MTEXwxi3akD3CFvrRB","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>