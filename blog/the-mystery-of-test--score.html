<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>My new cool app</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/4ac7ed34d61ef456.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4ac7ed34d61ef456.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-d38be8d96a62f950.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-9f90a364d66949ce.js" defer=""></script><script src="/_next/static/chunks/pages/_app-8cfbd06f8ddd0b49.js" defer=""></script><script src="/_next/static/chunks/675-262430aa11afdf01.js" defer=""></script><script src="/_next/static/chunks/9-9d15d34c7affe00b.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-fd50a1465d8f452c.js" defer=""></script><script src="/_next/static/MdneM3OWGZMTOR1krVaKX/_buildManifest.js" defer=""></script><script src="/_next/static/MdneM3OWGZMTOR1krVaKX/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.6">.iBQlkL{background:coral;height:60px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}/*!sc*/
@media (max-width:920px){.iBQlkL ul{display:none;}}/*!sc*/
data-styled.g1[id="sc-7295e4c-0"]{content:"iBQlkL,"}/*!sc*/
.bDMZDz{display:none;font-size:22px;margin-left:auto;}/*!sc*/
@media (max-width:920px){.bDMZDz{display:block;}}/*!sc*/
data-styled.g2[id="sc-7295e4c-1"]{content:"bDMZDz,"}/*!sc*/
html,body{height:100%;margin:0;}/*!sc*/
body{background:#fff;}/*!sc*/
html{box-sizing:border-box;font-size:16px;}/*!sc*/
*,*:before,*:after{box-sizing:inherit;}/*!sc*/
body,h1,h2,h3,h4,h5,h6,p,ol,ul{margin:0;padding:0;font-weight:normal;}/*!sc*/
ol,ul{list-style:none;}/*!sc*/
img,video{max-width:100%;height:auto;}/*!sc*/
.lg-container .lg-backdrop.in{opacity:0.75;}/*!sc*/
.lg-container .lg-toolbar.lg-group,.lg-container .lg-outer .lg-thumb-outer{background:rgba(0,0,0,0.45);}/*!sc*/
data-styled.g3[id="sc-global-cqyaiF1"]{content:"sc-global-cqyaiF1,"}/*!sc*/
.gndEvh{max-width:800px;margin:0 auto;}/*!sc*/
data-styled.g6[id="sc-6329e001-0"]{content:"gndEvh,"}/*!sc*/
</style></head><body><div id="__next"><nav class="sc-7295e4c-0 iBQlkL"><ul><a href="/blog">Blog</a></ul><button class="sc-7295e4c-1 bDMZDz">X</button></nav><main><div class="sc-6329e001-0 gndEvh"><h1>The Mystery of Test &amp; Score</h1><div class="lg-react-element "><p>Test &amp; Score is surely one the most used widgets in Orange. Fun fact: it is the fourth in popularity, right after Data Table, File and Scatter Plot. So let us dive into the nuts and bolts of the Test &amp; Score widget.</p>
<p>The widget generally accepts two inputs – Data and Learner. Data is the data set that we will be using for modeling, say, iris.tab that is already pre-loaded in the File widget. Learner is any kind of learning algorithm, for example, Logistic Regression. You can only use those learners that support your type of task. If you wish to do classification, you cannot use Linear Regression and for regression you cannot use Logistic Regression. Most other learners support both tasks. You can connect more than one learner to Test &amp; Score.</p>
<p>\</p>
<a href="/blog/2019-1-the-mystery-of-test-and-score/the-mystery-of-test-and-score-1.png" data-gallery="true"><img srcSet="/blog/2019-1-the-mystery-of-test-and-score/the-mystery-of-test-and-score-1.png 1x, /blog/2019-1-the-mystery-of-test-and-score/the-mystery-of-test-and-score-1.png 2x" src="/blog/2019-1-the-mystery-of-test-and-score/the-mystery-of-test-and-score-1.png" width="792" height="640" decoding="async" data-nimg="1" loading="lazy" style="color:transparent"/></a>
<p><br/>
<!-- -->\</p>
<p>Test &amp; Score will now use each connected Learner and the Data to build a predictive model. Models can be built in different ways. The most typical procedure is <strong>cross validation</strong>, which splits the data into k folds and uses k – 1 folds for training and the remaining fold for testing. This procedure is repeated, so that each fold has been used for testing exactly once. Test &amp; Score will then report on the average accuracy of the model.</p>
<p>You can also use <strong>Random Sampling</strong>, which will split the data into two sets with predefined proportions (e.g. 66% : 34%), build a model on the first set and test it on the second. This is similar to CV, except that each data instance can be used more than once for testing.</p>
<p><strong>Leave one out</strong> is again very similar to the above two methods, but it only takes one data instance for testing each time. If you have a 100 data instances, then 99 will be used for training and 1 for testing, and the procedure will be repeated a 100 times until every data instance was used once for testing. As you can imagine, this is a very time-intensive procedure and it is recommended for smaller data sets only.</p>
<p>Test on train data uses the whole data set for training and again the same data for testing. Because of overfitting, this will usually overestimate the performance! Test on test data requires an additional data input (Test Data) and allows the user to control both data sets (training and testing) used for evaluation.</p>
<p>Finally, you can also use <strong>cross validation by feature</strong>. Sometimes, you would have pre-defined folds for a procedure, that you wish to replicate. Then you can use Cross validation by feature to ensure data instances are split into the same folds every time. Just make sure the feature you are using for defining folds is a categorical variable and located in meta attributes.</p>
<p>Another scenario is when you have several examples from the same object, for example several measurements of the same patient or several images of the same plant. Then you absolutely want to make sure that all data instances for a particular object are in the same fold. Otherwise, your model would probably report severely overfitted scores.</p>
<p>\</p>
<a href="/blog/2019-1-the-mystery-of-test-and-score/the-mystery-of-test-and-score-2.png" data-gallery="true"><img srcSet="/blog/2019-1-the-mystery-of-test-and-score/the-mystery-of-test-and-score-2.png 1x, /blog/2019-1-the-mystery-of-test-and-score/the-mystery-of-test-and-score-2.png 2x" src="/blog/2019-1-the-mystery-of-test-and-score/the-mystery-of-test-and-score-2.png" width="1384" height="866" decoding="async" data-nimg="1" loading="lazy" style="color:transparent"/></a>
<p><br/>
<!-- -->\</p></div></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"frontmatter":{"author":"Ajda Pretnar","date":"2019-01-28","draft":false,"title":"The Mystery of Test \u0026 Score","type":"blog","thumbImage":"ts-blog.png","image":"","blog":["cross validation","leave one out","LOO","test and score"],"shortExcerpt":"Test \u0026 Score widget is used for evaluating model performance, but what do the methods do? We explain each of them in a few lines.","longExcerpt":"Test \u0026 Score widget is used for evaluating model performance, but what do the methods do? We explain cross validation, random sampling, leave one out and cross validation by feature in a few lines."},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    br: \"br\",\n    strong: \"strong\"\n  }, _provideComponents(), props.components), {Figure} = _components;\n  if (!Figure) _missingMdxReference(\"Figure\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"Test \u0026 Score is surely one the most used widgets in Orange. Fun fact: it is the fourth in popularity, right after Data Table, File and Scatter Plot. So let us dive into the nuts and bolts of the Test \u0026 Score widget.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The widget generally accepts two inputs – Data and Learner. Data is the data set that we will be using for modeling, say, iris.tab that is already pre-loaded in the File widget. Learner is any kind of learning algorithm, for example, Logistic Regression. You can only use those learners that support your type of task. If you wish to do classification, you cannot use Linear Regression and for regression you cannot use Logistic Regression. Most other learners support both tasks. You can connect more than one learner to Test \u0026 Score.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"\\\\\"\n    }), \"\\n\", _jsx(Figure, {\n      src: \"/blog/2019-1-the-mystery-of-test-and-score/the-mystery-of-test-and-score-1.png\",\n      width: \"40%\",\n      width: \"792\",\n      height: \"640\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.br, {}), \"\\n\", \"\\\\\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Test \u0026 Score will now use each connected Learner and the Data to build a predictive model. Models can be built in different ways. The most typical procedure is \", _jsx(_components.strong, {\n        children: \"cross validation\"\n      }), \", which splits the data into k folds and uses k – 1 folds for training and the remaining fold for testing. This procedure is repeated, so that each fold has been used for testing exactly once. Test \u0026 Score will then report on the average accuracy of the model.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"You can also use \", _jsx(_components.strong, {\n        children: \"Random Sampling\"\n      }), \", which will split the data into two sets with predefined proportions (e.g. 66% : 34%), build a model on the first set and test it on the second. This is similar to CV, except that each data instance can be used more than once for testing.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Leave one out\"\n      }), \" is again very similar to the above two methods, but it only takes one data instance for testing each time. If you have a 100 data instances, then 99 will be used for training and 1 for testing, and the procedure will be repeated a 100 times until every data instance was used once for testing. As you can imagine, this is a very time-intensive procedure and it is recommended for smaller data sets only.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Test on train data uses the whole data set for training and again the same data for testing. Because of overfitting, this will usually overestimate the performance! Test on test data requires an additional data input (Test Data) and allows the user to control both data sets (training and testing) used for evaluation.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Finally, you can also use \", _jsx(_components.strong, {\n        children: \"cross validation by feature\"\n      }), \". Sometimes, you would have pre-defined folds for a procedure, that you wish to replicate. Then you can use Cross validation by feature to ensure data instances are split into the same folds every time. Just make sure the feature you are using for defining folds is a categorical variable and located in meta attributes.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Another scenario is when you have several examples from the same object, for example several measurements of the same patient or several images of the same plant. Then you absolutely want to make sure that all data instances for a particular object are in the same fold. Otherwise, your model would probably report severely overfitted scores.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"\\\\\"\n    }), \"\\n\", _jsx(Figure, {\n      src: \"/blog/2019-1-the-mystery-of-test-and-score/the-mystery-of-test-and-score-2.png\",\n      width: \"70%\",\n      width: \"1384\",\n      height: \"866\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.br, {}), \"\\n\", \"\\\\\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"the-mystery-of-test--score"},"buildId":"MdneM3OWGZMTOR1krVaKX","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>