<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>My new cool app</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/4ac7ed34d61ef456.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4ac7ed34d61ef456.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-d38be8d96a62f950.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-9f90a364d66949ce.js" defer=""></script><script src="/_next/static/chunks/pages/_app-8cfbd06f8ddd0b49.js" defer=""></script><script src="/_next/static/chunks/675-262430aa11afdf01.js" defer=""></script><script src="/_next/static/chunks/9-9d15d34c7affe00b.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-ba4a3f289f8ef3c5.js" defer=""></script><script src="/_next/static/t3FkTJiCx_jp9wzVJgeAY/_buildManifest.js" defer=""></script><script src="/_next/static/t3FkTJiCx_jp9wzVJgeAY/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.6">.iBQlkL{background:coral;height:60px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}/*!sc*/
@media (max-width:920px){.iBQlkL ul{display:none;}}/*!sc*/
data-styled.g1[id="sc-7295e4c-0"]{content:"iBQlkL,"}/*!sc*/
.bDMZDz{display:none;font-size:22px;margin-left:auto;}/*!sc*/
@media (max-width:920px){.bDMZDz{display:block;}}/*!sc*/
data-styled.g2[id="sc-7295e4c-1"]{content:"bDMZDz,"}/*!sc*/
html,body{height:100%;margin:0;}/*!sc*/
body{background:#fff;}/*!sc*/
html{box-sizing:border-box;font-size:16px;}/*!sc*/
*,*:before,*:after{box-sizing:inherit;}/*!sc*/
body,h1,h2,h3,h4,h5,h6,p,ol,ul{margin:0;padding:0;font-weight:normal;}/*!sc*/
ol,ul{list-style:none;}/*!sc*/
img,video{max-width:100%;height:auto;}/*!sc*/
.lg-container .lg-backdrop.in{opacity:0.75;}/*!sc*/
.lg-container .lg-toolbar.lg-group,.lg-container .lg-outer .lg-thumb-outer{background:rgba(0,0,0,0.45);}/*!sc*/
data-styled.g3[id="sc-global-cqyaiF1"]{content:"sc-global-cqyaiF1,"}/*!sc*/
.cGDPDa{max-width:800px;margin:0 auto;}/*!sc*/
data-styled.g6[id="sc-f0e62130-0"]{content:"cGDPDa,"}/*!sc*/
</style></head><body><div id="__next"><nav class="sc-7295e4c-0 iBQlkL"><ul><a href="/blog">Blog</a></ul><button class="sc-7295e4c-1 bDMZDz">X</button></nav><main><div class="sc-f0e62130-0 cGDPDa"><h1>Orange NMF add-on</h1><div class="lg-react-element "><p><a href="http://nimfa.biolab.si">Nimfa</a>, a Python library for non-negative matrix factorization (NMF), which was part of Orange GSoC program back in 2011 got its own <a href="http://orange.biolab.si/addons/">add-on</a>.</p>
<p>Nimfa provides a plethora of initialization and factorization algorithms, quality measures along with examples on real-world and synthetic data sets. However, until now the analysis was possible only through Python scripting. A recent increase of interest in NMF techniques motivated Fajwel Fogel (a PhD student from INRIA, Paris, <a href="http://www.di.ens.fr/sierra/">SIERRA team</a>) to design and implement several widgets that deal with missing data in target matrices, their normalizations, viewing and assessing the quality of matrix factors returned by different matrix factorization algorithms. He also provided an implementation of robust singular value decomposition (rSVD). All NMF methods call Nimfa library.</p>
<a href="/blog/2013-02-orange-nmf-add-on/__webp-images__/nmf-addon-demo.png__1000x1000_q95.webp" data-gallery="true"><img alt="" srcSet="/blog/2013-02-orange-nmf-add-on/__webp-images__/nmf-addon-demo.png__1000x1000_q95.webp 1x, /blog/2013-02-orange-nmf-add-on/__webp-images__/nmf-addon-demo.png__1000x1000_q95.webp 2x" src="/blog/2013-02-orange-nmf-add-on/__webp-images__/nmf-addon-demo.png__1000x1000_q95.webp" width="527" height="497" decoding="async" data-nimg="1" loading="lazy" style="color:transparent"/></a>
<p>Above is shown a simple scenario in Orange that applies <a href="http://nimfa.biolab.si/nimfa.methods.factorization.lsnmf.html">LSNMF algorithm from Nimfa</a> to decompose a non-negative target matrix and visualizes its basis matrix (W) and coefficient matrix (H) as heat maps. NMF finds a parts-based representation of the data due to the fact that only additive, not subtractive, combinations are allowed, which results in improved interpretability of matrix factors. That is possible because non-negativity constraints are imposed in the NMF model in contrast to SVD, PCA and ICA, which provide only holistic representations. The effect can be easily seen if we investigate heat maps produced by the scenario above. Below are shown the target, basis and coefficient matrices (from left to right, top down), respectively.</p>
<a href="/blog/2013-02-orange-nmf-add-on/__webp-images__/lsnmf-addon-demo.png__432x826_q95_crop_upscale.webp" data-gallery="true"><img alt="" srcSet="/blog/2013-02-orange-nmf-add-on/__webp-images__/lsnmf-addon-demo.png__432x826_q95_crop_upscale.webp 1x, /blog/2013-02-orange-nmf-add-on/__webp-images__/lsnmf-addon-demo.png__432x826_q95_crop_upscale.webp 2x" src="/blog/2013-02-orange-nmf-add-on/__webp-images__/lsnmf-addon-demo.png__432x826_q95_crop_upscale.webp" width="432" height="826" decoding="async" data-nimg="1" loading="lazy" style="color:transparent"/></a></div></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"frontmatter":{"author":"BIOLAB","date":"2013-02-06 13:47:00+00:00","draft":false,"title":"Orange NMF add-on","type":"blog","blog":["addons","matrixfactorization","nmf"]},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    img: \"img\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [_jsx(_components.a, {\n        href: \"http://nimfa.biolab.si\",\n        children: \"Nimfa\"\n      }), \", a Python library for non-negative matrix factorization (NMF), which was part of Orange GSoC program back in 2011 got its own \", _jsx(_components.a, {\n        href: \"http://orange.biolab.si/addons/\",\n        children: \"add-on\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Nimfa provides a plethora of initialization and factorization algorithms, quality measures along with examples on real-world and synthetic data sets. However, until now the analysis was possible only through Python scripting. A recent increase of interest in NMF techniques motivated Fajwel Fogel (a PhD student from INRIA, Paris, \", _jsx(_components.a, {\n        href: \"http://www.di.ens.fr/sierra/\",\n        children: \"SIERRA team\"\n      }), \") to design and implement several widgets that deal with missing data in target matrices, their normalizations, viewing and assessing the quality of matrix factors returned by different matrix factorization algorithms. He also provided an implementation of robust singular value decomposition (rSVD). All NMF methods call Nimfa library.\"]\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/blog/2013-02-orange-nmf-add-on/__webp-images__/nmf-addon-demo.png__1000x1000_q95.webp\",\n      alt: \"\",\n      width: \"527\",\n      height: \"497\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Above is shown a simple scenario in Orange that applies \", _jsx(_components.a, {\n        href: \"http://nimfa.biolab.si/nimfa.methods.factorization.lsnmf.html\",\n        children: \"LSNMF algorithm from Nimfa\"\n      }), \" to decompose a non-negative target matrix and visualizes its basis matrix (W) and coefficient matrix (H) as heat maps. NMF finds a parts-based representation of the data due to the fact that only additive, not subtractive, combinations are allowed, which results in improved interpretability of matrix factors. That is possible because non-negativity constraints are imposed in the NMF model in contrast to SVD, PCA and ICA, which provide only holistic representations. The effect can be easily seen if we investigate heat maps produced by the scenario above. Below are shown the target, basis and coefficient matrices (from left to right, top down), respectively.\"]\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/blog/2013-02-orange-nmf-add-on/__webp-images__/lsnmf-addon-demo.png__432x826_q95_crop_upscale.webp\",\n      alt: \"\",\n      width: \"432\",\n      height: \"826\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"orange-nmf-add-on"},"buildId":"t3FkTJiCx_jp9wzVJgeAY","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>