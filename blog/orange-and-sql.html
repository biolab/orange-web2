<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>My new cool app</title><meta name="next-head-count" content="3"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-d38be8d96a62f950.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-1b5205ad35b92557.js" defer=""></script><script src="/_next/static/chunks/pages/_app-72ed113f22a36849.js" defer=""></script><script src="/_next/static/chunks/675-44addd24cc62f3a3.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-6a5b6173e98f113c.js" defer=""></script><script src="/_next/static/CX8-OElU8TqTkW2zxyeBX/_buildManifest.js" defer=""></script><script src="/_next/static/CX8-OElU8TqTkW2zxyeBX/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.6">.iBQlkL{background:coral;height:60px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}/*!sc*/
@media (max-width:920px){.iBQlkL ul{display:none;}}/*!sc*/
data-styled.g1[id="sc-7295e4c-0"]{content:"iBQlkL,"}/*!sc*/
.bDMZDz{display:none;font-size:22px;margin-left:auto;}/*!sc*/
@media (max-width:920px){.bDMZDz{display:block;}}/*!sc*/
data-styled.g2[id="sc-7295e4c-1"]{content:"bDMZDz,"}/*!sc*/
html,body{height:100%;margin:0;}/*!sc*/
body{background:#fff;}/*!sc*/
html{box-sizing:border-box;font-size:16px;}/*!sc*/
*,*:before,*:after{box-sizing:inherit;}/*!sc*/
body,h1,h2,h3,h4,h5,h6,p,ol,ul{margin:0;padding:0;font-weight:normal;}/*!sc*/
ol,ul{list-style:none;}/*!sc*/
img,video{max-width:100%;height:auto;}/*!sc*/
data-styled.g3[id="sc-global-eYmBoQ1"]{content:"sc-global-eYmBoQ1,"}/*!sc*/
.ufdhg{max-width:800px;margin:0 auto;}/*!sc*/
data-styled.g4[id="sc-dab4a0e4-0"]{content:"ufdhg,"}/*!sc*/
</style></head><body><div id="__next"><nav class="sc-7295e4c-0 iBQlkL"><ul><a href="/blog">Blog</a></ul><button class="sc-7295e4c-1 bDMZDz">X</button></nav><main><div class="sc-dab4a0e4-0 ufdhg"><h1>Orange and SQL</h1><p>Orange 3.0 will also support working with data stored in a database.</p>
<p>While we have already talked about this some time ago, we here describe some technical details for anybody interested. This is not a thorough tecnical report, its purpose is only to provide an impression about the architecture of the upcoming version of Orange.</p>
<p>So, data tables in Orange 3.0 can refer to data in the working memory or in the database. Any (properly written) code that uses tables should work the same with both storages. When the data is stored in the database, the table is implemented as a &quot;proxy object&quot; with the necessary meta-data for constructing the SQL query to retrieve the data when needed. Operations on the data only modify the meta-data without retrieving any actual data. For instance, construction of a new table with some selected data subset, say all instances that match a certain condition, creates a new proxy with additional conditions for the WHERE clause. Similarly, selecting a subset of features only changes the domain (the list of features), which is later reflected in the columns of the SELECT clause.</p>
<p>Features in this model are no longer described just with their names but also with the part which goes into the query that retrieves or constructs their values. Discretization, for instance, constructs new features which wrap the representation of the continuous features into a CASE statement that assigns a value based on the boundaries of the bins.</p>
<p>Since the goal was to make the code in modules and widgets oblivious to the storage, we also needed separate implementation of the operations that need to be aware of how the data is stored. For instance, the code that computes the average values of attributes needs to be different for the two storages: for the in-memory data we need to use the corresponding numpy functions and for databases the average is computed on the server.</p>
<p>We went through the code of Orange 2.7 and identified the common operations on the data. We found that all data access belongs into the following types:</p>
<ol>
<li>basic aggregates like mean, variance, median, minimal and maximal value,</li>
<li>distributions of discrete and continuous variables, values at percentiles,</li>
<li>contingency matrices,</li>
<li>covariance matrices,</li>
<li>filtering of rows based on various criteria, including random sampling,</li>
<li>selection of columns,</li>
<li>construction of variables from values of other variables,</li>
<li>matrices of distances (e.g. Euclidean) between all row pairs,</li>
<li>individual data rows.</li>
</ol>
<p>Points 1 to 4 are typical examples of what cannot be done on client but can be efficiently done in the database. The storage (a class derived from Table) now provides specialized methods for computing aggregates, distributions and contingencies, which use numpy for in-memory data and SQL for the data on the database.</p>
<p>Points 5 to 7 are implemented “lazily”, by modifying the SQL query describing the data as described above.</p>
<p>Point 8 is difficult to implement efficiently in common relational databases and, besides, results in a data matrix that is larger than the actual data. Methods that require such a matrix will need to be reimplemented and be aware of the storage mechanism.</p>
<p>Point 9 requires some caution with regard to how the data is retrieved and what it is used for. Access to individual rows should be used sparingly. Sequential retrieval - especially of all rows - needs to be avoided. For efficiency, most methods that did so in the previous versions of Orange will need to be reimplemented to use aggregate data (possibly as approximations) or to be aware of the data storage and execute some operations directly through SQL.</p>
<p>We have already ported a number of visualizations and other widgets to the new Orange. Here is one nice example: Mosaic needs to discretize the variables and then compute contingency matrices for discrete variables. Within the above scheme, the widget does not care about the storage mechanism, yet its computation is still as efficient as possible.</p>
<p><img src="/blog/2014-05-orange-and-sql/mosaic.png__600x408_q95_upscale.png" alt=""/></p>
<p>The described activities were funded in part by the European Union&#x27;s Seventh Framework Programme (FP7/2007-2013) under grant agreement n° 318633.</p></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"frontmatter":{"author":"BIOLAB","date":"2014-05-29 22:34:00+00:00","draft":false,"title":"Orange and SQL","type":"blog","blog":["orange3"]},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    ol: \"ol\",\n    li: \"li\",\n    img: \"img\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"Orange 3.0 will also support working with data stored in a database.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"While we have already talked about this some time ago, we here describe some technical details for anybody interested. This is not a thorough tecnical report, its purpose is only to provide an impression about the architecture of the upcoming version of Orange.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"So, data tables in Orange 3.0 can refer to data in the working memory or in the database. Any (properly written) code that uses tables should work the same with both storages. When the data is stored in the database, the table is implemented as a \\\"proxy object\\\" with the necessary meta-data for constructing the SQL query to retrieve the data when needed. Operations on the data only modify the meta-data without retrieving any actual data. For instance, construction of a new table with some selected data subset, say all instances that match a certain condition, creates a new proxy with additional conditions for the WHERE clause. Similarly, selecting a subset of features only changes the domain (the list of features), which is later reflected in the columns of the SELECT clause.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Features in this model are no longer described just with their names but also with the part which goes into the query that retrieves or constructs their values. Discretization, for instance, constructs new features which wrap the representation of the continuous features into a CASE statement that assigns a value based on the boundaries of the bins.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Since the goal was to make the code in modules and widgets oblivious to the storage, we also needed separate implementation of the operations that need to be aware of how the data is stored. For instance, the code that computes the average values of attributes needs to be different for the two storages: for the in-memory data we need to use the corresponding numpy functions and for databases the average is computed on the server.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We went through the code of Orange 2.7 and identified the common operations on the data. We found that all data access belongs into the following types:\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"basic aggregates like mean, variance, median, minimal and maximal value,\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"distributions of discrete and continuous variables, values at percentiles,\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"contingency matrices,\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"covariance matrices,\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"filtering of rows based on various criteria, including random sampling,\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"selection of columns,\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"construction of variables from values of other variables,\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"matrices of distances (e.g. Euclidean) between all row pairs,\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"individual data rows.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Points 1 to 4 are typical examples of what cannot be done on client but can be efficiently done in the database. The storage (a class derived from Table) now provides specialized methods for computing aggregates, distributions and contingencies, which use numpy for in-memory data and SQL for the data on the database.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Points 5 to 7 are implemented “lazily”, by modifying the SQL query describing the data as described above.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Point 8 is difficult to implement efficiently in common relational databases and, besides, results in a data matrix that is larger than the actual data. Methods that require such a matrix will need to be reimplemented and be aware of the storage mechanism.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Point 9 requires some caution with regard to how the data is retrieved and what it is used for. Access to individual rows should be used sparingly. Sequential retrieval - especially of all rows - needs to be avoided. For efficiency, most methods that did so in the previous versions of Orange will need to be reimplemented to use aggregate data (possibly as approximations) or to be aware of the data storage and execute some operations directly through SQL.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We have already ported a number of visualizations and other widgets to the new Orange. Here is one nice example: Mosaic needs to discretize the variables and then compute contingency matrices for discrete variables. Within the above scheme, the widget does not care about the storage mechanism, yet its computation is still as efficient as possible.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/blog/2014-05-orange-and-sql/mosaic.png__600x408_q95_upscale.png\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The described activities were funded in part by the European Union's Seventh Framework Programme (FP7/2007-2013) under grant agreement n° 318633.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"orange-and-sql"},"buildId":"CX8-OElU8TqTkW2zxyeBX","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>