<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>My new cool app</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/4ac7ed34d61ef456.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4ac7ed34d61ef456.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-d38be8d96a62f950.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-9f90a364d66949ce.js" defer=""></script><script src="/_next/static/chunks/pages/_app-8cfbd06f8ddd0b49.js" defer=""></script><script src="/_next/static/chunks/675-262430aa11afdf01.js" defer=""></script><script src="/_next/static/chunks/9-9d15d34c7affe00b.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-ba4a3f289f8ef3c5.js" defer=""></script><script src="/_next/static/Hp3T9eILuyLvNqJWUICxV/_buildManifest.js" defer=""></script><script src="/_next/static/Hp3T9eILuyLvNqJWUICxV/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.6">.iBQlkL{background:coral;height:60px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}/*!sc*/
@media (max-width:920px){.iBQlkL ul{display:none;}}/*!sc*/
data-styled.g1[id="sc-7295e4c-0"]{content:"iBQlkL,"}/*!sc*/
.bDMZDz{display:none;font-size:22px;margin-left:auto;}/*!sc*/
@media (max-width:920px){.bDMZDz{display:block;}}/*!sc*/
data-styled.g2[id="sc-7295e4c-1"]{content:"bDMZDz,"}/*!sc*/
html,body{height:100%;margin:0;}/*!sc*/
body{background:#fff;}/*!sc*/
html{box-sizing:border-box;font-size:16px;}/*!sc*/
*,*:before,*:after{box-sizing:inherit;}/*!sc*/
body,h1,h2,h3,h4,h5,h6,p,ol,ul{margin:0;padding:0;font-weight:normal;}/*!sc*/
ol,ul{list-style:none;}/*!sc*/
img,video{max-width:100%;height:auto;}/*!sc*/
.lg-container .lg-backdrop.in{opacity:0.75;}/*!sc*/
.lg-container .lg-toolbar.lg-group,.lg-container .lg-outer .lg-thumb-outer{background:rgba(0,0,0,0.45);}/*!sc*/
data-styled.g3[id="sc-global-cqyaiF1"]{content:"sc-global-cqyaiF1,"}/*!sc*/
.cGDPDa{max-width:800px;margin:0 auto;}/*!sc*/
data-styled.g6[id="sc-f0e62130-0"]{content:"cGDPDa,"}/*!sc*/
</style></head><body><div id="__next"><nav class="sc-7295e4c-0 iBQlkL"><ul><a href="/blog">Blog</a></ul><button class="sc-7295e4c-1 bDMZDz">X</button></nav><main><div class="sc-f0e62130-0 cGDPDa"><h1>Overfitting and Regularization</h1><div class="lg-react-element "><p>A week ago I used <a href="http://orange.biolab.si">Orange</a> to explain the effects of regularization. This was the second lecture in the Data Mining class, the first one was on linear regression. My introduction to the benefits of regularization used a simple data set with a single input attribute and a continuous class. I drew a data set in Orange, and then used Polynomial Regression widget (from Prototypes add-on) to plot the linear fit. This widget can also expand the data set by adding columns with powers of original attribute x, thereby augmenting the training set with x^p, where x is our original attribute and p an integer going from 2 to K. The polynomial expansion of data sets allows linear regression model to nicely fit the data, and with higher K to overfit it to extreme, especially if the number of data points in the training set is low.</p>
<a href="/blog/2016-03-overfitting-and-regularization/__webp-images__/poly-overfit.webp" data-gallery="true"><img alt="" srcSet="/blog/2016-03-overfitting-and-regularization/__webp-images__/poly-overfit.webp 1x, /blog/2016-03-overfitting-and-regularization/__webp-images__/poly-overfit.webp 2x" src="/blog/2016-03-overfitting-and-regularization/__webp-images__/poly-overfit.webp" width="899" height="711" decoding="async" data-nimg="1" loading="lazy" style="color:transparent"/></a>
<p>We have already <a href="/blog/2015/10/02/a-visit-from-the-tilburg-university/">blogged</a> about this experiment a while ago, showing that it is easy to see that linear regression coefficients blow out of proportion with increasing K. This leads to the idea that linear regression should not only minimize the squared error when predicting the value of dependent variable in the training set, but also keep model coefficients low, or better, penalize any high value of coefficients. This procedure is called regularization. Based on the type of penalty (sum of coefficient squared or sum of absolute values), the regularization is referred to L1 or L2, or, ridge and lasso regression.</p>
<p>It is quite easy to play with regularized models in Orange by attaching a Linear Regression widget to Polynomial Regression, in this way substituting the default model used in Polynomial Regression with the one designed in Linear Regression widget. This makes available different kinds of regularization. This workflow can be used to show that the regularized models less overfit the data, and that the overfitting depends on the regularization coefficient which governs the degree of penalty stemming from the value of coefficients of the linear model.</p>
<a href="/blog/2016-03-overfitting-and-regularization/__webp-images__/poly-l2.webp" data-gallery="true"><img alt="" srcSet="/blog/2016-03-overfitting-and-regularization/__webp-images__/poly-l2.webp 1x, /blog/2016-03-overfitting-and-regularization/__webp-images__/poly-l2.webp 2x" src="/blog/2016-03-overfitting-and-regularization/__webp-images__/poly-l2.webp" width="1027" height="853" decoding="async" data-nimg="1" loading="lazy" style="color:transparent"/></a>
<p>I also use this workflow to show the difference between L1 and L2 regularization. The change of the type of regularization is most pronounced in the table of coefficients (Data Table widget), where with L1 regularization it is clear that this procedure results in many of those being 0. Try this with high value for degree of polynomial expansion, and a data set with about 10 data points. Also, try changing the regularization regularization strength (Linear Regression widget).</p>
<a href="/blog/2016-03-overfitting-and-regularization/__webp-images__/poly-l1.webp" data-gallery="true"><img alt="" srcSet="/blog/2016-03-overfitting-and-regularization/__webp-images__/poly-l1.webp 1x, /blog/2016-03-overfitting-and-regularization/__webp-images__/poly-l1.webp 2x" src="/blog/2016-03-overfitting-and-regularization/__webp-images__/poly-l1.webp" width="816" height="449" decoding="async" data-nimg="1" loading="lazy" style="color:transparent"/></a>
<p>While the effects of overfitting and regularization are nicely visible in the plot in Polynomial Regression widget, machine learning models are really about predictions. And the quality of predictions should really be estimated on independent test set. So at this stage of the lecture I needed to introduce the model scoring, that is, a measure that tells me how well my model inferred on the training set performs on the test set. For simplicity, I chose to introduce root mean squared error (RMSE) and then crafted the following workflow.</p>
<a href="/blog/2016-03-overfitting-and-regularization/__webp-images__/poly-evaluate.webp" data-gallery="true"><img alt="" srcSet="/blog/2016-03-overfitting-and-regularization/__webp-images__/poly-evaluate.webp 1x, /blog/2016-03-overfitting-and-regularization/__webp-images__/poly-evaluate.webp 2x" src="/blog/2016-03-overfitting-and-regularization/__webp-images__/poly-evaluate.webp" width="736" height="829" decoding="async" data-nimg="1" loading="lazy" style="color:transparent"/></a>
<p>Here, I draw the data set (Paint Data, about 20 data instances), assigned y as the target variable (Select Columns), split the data to training and test sets of approximately equal sizes (Data Sampler), and pass training and test data and linear model to the Test &amp; Score widget. Then I can use linear regression with no regularization, and expect how RMSE changes with changing the degree of the polynomial. I can alternate between Test on train data and Test on test data (Test &amp; Score widget). In the class I have used the blackboard to record this dependency. For the data from the figure, I got the following table:</p>
<pre><code>		Poly K, RMSE Train, RMSE Test
		0,       0.147,      0.138
		1, 		 0.155, 	 0.192
		2, 		 0.049, 	 0.063
		3, 		 0.049, 	 0.063
		4, 		 0.049, 	 0.067
		5, 		 0.040, 	 0.408
		6, 		 0.040, 	 0.574
		7, 		 0.033, 	 2.681
		8, 		 0.001, 	 5.734
		9, 		 0.000, 	 4.776
</code></pre>
<p>That&#x27;s it. For the class of computer scientists, one may do all this in scripting, but for any other audience, or for any introductory lesson, explaining of regularization with Orange widgets is a lot of fun.</p></div></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"frontmatter":{"author":"BLAZ","date":"2016-03-12 16:48:38+00:00","draft":false,"title":"Overfitting and Regularization","type":"blog","blog":["analysis","education","examples","orange3","overfitting","plot","regression","tutorial"]},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    img: \"img\",\n    pre: \"pre\",\n    code: \"code\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"A week ago I used \", _jsx(_components.a, {\n        href: \"http://orange.biolab.si\",\n        children: \"Orange\"\n      }), \" to explain the effects of regularization. This was the second lecture in the Data Mining class, the first one was on linear regression. My introduction to the benefits of regularization used a simple data set with a single input attribute and a continuous class. I drew a data set in Orange, and then used Polynomial Regression widget (from Prototypes add-on) to plot the linear fit. This widget can also expand the data set by adding columns with powers of original attribute x, thereby augmenting the training set with x^p, where x is our original attribute and p an integer going from 2 to K. The polynomial expansion of data sets allows linear regression model to nicely fit the data, and with higher K to overfit it to extreme, especially if the number of data points in the training set is low.\"]\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/blog/2016-03-overfitting-and-regularization/__webp-images__/poly-overfit.webp\",\n      alt: \"\",\n      width: \"899\",\n      height: \"711\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"We have already \", _jsx(_components.a, {\n        href: \"/blog/2015/10/02/a-visit-from-the-tilburg-university/\",\n        children: \"blogged\"\n      }), \" about this experiment a while ago, showing that it is easy to see that linear regression coefficients blow out of proportion with increasing K. This leads to the idea that linear regression should not only minimize the squared error when predicting the value of dependent variable in the training set, but also keep model coefficients low, or better, penalize any high value of coefficients. This procedure is called regularization. Based on the type of penalty (sum of coefficient squared or sum of absolute values), the regularization is referred to L1 or L2, or, ridge and lasso regression.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"It is quite easy to play with regularized models in Orange by attaching a Linear Regression widget to Polynomial Regression, in this way substituting the default model used in Polynomial Regression with the one designed in Linear Regression widget. This makes available different kinds of regularization. This workflow can be used to show that the regularized models less overfit the data, and that the overfitting depends on the regularization coefficient which governs the degree of penalty stemming from the value of coefficients of the linear model.\"\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/blog/2016-03-overfitting-and-regularization/__webp-images__/poly-l2.webp\",\n      alt: \"\",\n      width: \"1027\",\n      height: \"853\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"I also use this workflow to show the difference between L1 and L2 regularization. The change of the type of regularization is most pronounced in the table of coefficients (Data Table widget), where with L1 regularization it is clear that this procedure results in many of those being 0. Try this with high value for degree of polynomial expansion, and a data set with about 10 data points. Also, try changing the regularization regularization strength (Linear Regression widget).\"\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/blog/2016-03-overfitting-and-regularization/__webp-images__/poly-l1.webp\",\n      alt: \"\",\n      width: \"816\",\n      height: \"449\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"While the effects of overfitting and regularization are nicely visible in the plot in Polynomial Regression widget, machine learning models are really about predictions. And the quality of predictions should really be estimated on independent test set. So at this stage of the lecture I needed to introduce the model scoring, that is, a measure that tells me how well my model inferred on the training set performs on the test set. For simplicity, I chose to introduce root mean squared error (RMSE) and then crafted the following workflow.\"\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/blog/2016-03-overfitting-and-regularization/__webp-images__/poly-evaluate.webp\",\n      alt: \"\",\n      width: \"736\",\n      height: \"829\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Here, I draw the data set (Paint Data, about 20 data instances), assigned y as the target variable (Select Columns), split the data to training and test sets of approximately equal sizes (Data Sampler), and pass training and test data and linear model to the Test \u0026 Score widget. Then I can use linear regression with no regularization, and expect how RMSE changes with changing the degree of the polynomial. I can alternate between Test on train data and Test on test data (Test \u0026 Score widget). In the class I have used the blackboard to record this dependency. For the data from the figure, I got the following table:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"\\t\\tPoly K, RMSE Train, RMSE Test\\n\\t\\t0,       0.147,      0.138\\n\\t\\t1, \\t\\t 0.155, \\t 0.192\\n\\t\\t2, \\t\\t 0.049, \\t 0.063\\n\\t\\t3, \\t\\t 0.049, \\t 0.063\\n\\t\\t4, \\t\\t 0.049, \\t 0.067\\n\\t\\t5, \\t\\t 0.040, \\t 0.408\\n\\t\\t6, \\t\\t 0.040, \\t 0.574\\n\\t\\t7, \\t\\t 0.033, \\t 2.681\\n\\t\\t8, \\t\\t 0.001, \\t 5.734\\n\\t\\t9, \\t\\t 0.000, \\t 4.776\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"That's it. For the class of computer scientists, one may do all this in scripting, but for any other audience, or for any introductory lesson, explaining of regularization with Orange widgets is a lot of fun.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"overfitting-and-regularization"},"buildId":"Hp3T9eILuyLvNqJWUICxV","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>