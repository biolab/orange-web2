<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>My new cool app</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/4ac7ed34d61ef456.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4ac7ed34d61ef456.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-d38be8d96a62f950.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-9f90a364d66949ce.js" defer=""></script><script src="/_next/static/chunks/pages/_app-8cfbd06f8ddd0b49.js" defer=""></script><script src="/_next/static/chunks/675-262430aa11afdf01.js" defer=""></script><script src="/_next/static/chunks/9-9d15d34c7affe00b.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-ba4a3f289f8ef3c5.js" defer=""></script><script src="/_next/static/k-9TZ-ZrkQDGbtdjjI5V3/_buildManifest.js" defer=""></script><script src="/_next/static/k-9TZ-ZrkQDGbtdjjI5V3/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.6">.iBQlkL{background:coral;height:60px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}/*!sc*/
@media (max-width:920px){.iBQlkL ul{display:none;}}/*!sc*/
data-styled.g1[id="sc-7295e4c-0"]{content:"iBQlkL,"}/*!sc*/
.bDMZDz{display:none;font-size:22px;margin-left:auto;}/*!sc*/
@media (max-width:920px){.bDMZDz{display:block;}}/*!sc*/
data-styled.g2[id="sc-7295e4c-1"]{content:"bDMZDz,"}/*!sc*/
html,body{height:100%;margin:0;}/*!sc*/
body{background:#fff;}/*!sc*/
html{box-sizing:border-box;font-size:16px;}/*!sc*/
*,*:before,*:after{box-sizing:inherit;}/*!sc*/
body,h1,h2,h3,h4,h5,h6,p,ol,ul{margin:0;padding:0;font-weight:normal;}/*!sc*/
ol,ul{list-style:none;}/*!sc*/
img,video{max-width:100%;height:auto;}/*!sc*/
.lg-container .lg-backdrop.in{opacity:0.75;}/*!sc*/
.lg-container .lg-toolbar.lg-group,.lg-container .lg-outer .lg-thumb-outer{background:rgba(0,0,0,0.45);}/*!sc*/
data-styled.g3[id="sc-global-cqyaiF1"]{content:"sc-global-cqyaiF1,"}/*!sc*/
.cGDPDa{max-width:800px;margin:0 auto;}/*!sc*/
data-styled.g6[id="sc-f0e62130-0"]{content:"cGDPDa,"}/*!sc*/
</style></head><body><div id="__next"><nav class="sc-7295e4c-0 iBQlkL"><ul><a href="/blog">Blog</a></ul><button class="sc-7295e4c-1 bDMZDz">X</button></nav><main><div class="sc-f0e62130-0 cGDPDa"><h1>Scripting with Time Variable</h1><div class="lg-react-element "><p>It&#x27;s always fun to play around with data. And since Orange can, as of a few months ago, read temporal data, we decided to parse some data we had and put it into Orange.</p>
<p>TimeVariable is an extended class of continuous variable and it works with properly formated ISO standard datetime (Y-M-D h:m:s). Oftentimes our original data is not in the right format and needs to be edited first, so Orange can read it. Python&#x27;s own datetime module is of great help. You can give it any date format and tell it how to interpret it in the argument.</p>
<pre><code>    import datetime
    date = &quot;13.03.2013 13:13:31&quot;
    new_date = str(datetime.datetime.strptime(date, &quot;%d.%m.%Y %H:%M:%S&quot;))
    &gt;&gt;&gt; &#x27;2013-03-13 13:13:31&#x27;
</code></pre>
<p>Do this for all your datetime attributes. This will transform them into strings that Orange&#x27;s TimeVariable can read. Then create a new data table:</p>
<pre><code>    import Orange
    from Orange.data import Domain, TimeVariable
    domain = Domain([TimeVariable(&quot;timestamp&quot;)])
    timestamps = [&quot;2013-03-13 13:13:31&quot;, &quot;2014-04-14 14:14:41&quot;, &quot;2015-05-15 15:15:51&quot;]
    #create a new TimeVariable object
    time_var = TimeVariable()
    #it&#x27;s important to parse strings into floats with var.parse(i)
    #list(zip(data)) then transforms the list into a 2d list of lists
    time_data = Orange.data.Table(domain, list(zip(time_var.parse(i) for i in timestamps)))
</code></pre>
<p>Now say you have some original data you want to append your new data to.</p>
<pre><code>    data = Orange.data.Table.concatenate([original_data, time_data])
    Table.save(data, &quot;data.tab&quot;)
</code></pre>
<p>But what if you want to select only a few attributes from the original data? It can be arranged.</p>
<pre><code>    original_data = Orange.data.Table(&quot;original_data.tab&quot;)
    new_domain = Domain([&quot;attribute_1&quot;, &quot;attribute_2&quot;], source=original_data.domain)
    new_data = Orange.data.Table(new_domain, original_data)
</code></pre>
<p>Then concatenate again:</p>
<pre><code>    data = Orange.data.Table.concatenate([new_data, time_data])
    Table.save(data, &quot;selected_data.tab&quot;)
</code></pre>
<p>Remember, if your data has string variables, they will always be in meta attributes.</p>
<pre><code>    domain = Domain([&quot;some_attribute1&quot;, &quot;other_attribute2&quot;], metas=[&quot;some_string_variable&quot;])
</code></pre>
<p>Have fun scripting!</p></div></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"frontmatter":{"author":"AJDA","date":"2016-06-10 12:37:50+00:00","draft":false,"title":"Scripting with Time Variable","type":"blog","blog":["data","examples","scripting","orange3"]},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    pre: \"pre\",\n    code: \"code\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"It's always fun to play around with data. And since Orange can, as of a few months ago, read temporal data, we decided to parse some data we had and put it into Orange.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"TimeVariable is an extended class of continuous variable and it works with properly formated ISO standard datetime (Y-M-D h:m:s). Oftentimes our original data is not in the right format and needs to be edited first, so Orange can read it. Python's own datetime module is of great help. You can give it any date format and tell it how to interpret it in the argument.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"    import datetime\\n    date = \\\"13.03.2013 13:13:31\\\"\\n    new_date = str(datetime.datetime.strptime(date, \\\"%d.%m.%Y %H:%M:%S\\\"))\\n    \u003e\u003e\u003e '2013-03-13 13:13:31'\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Do this for all your datetime attributes. This will transform them into strings that Orange's TimeVariable can read. Then create a new data table:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"    import Orange\\n    from Orange.data import Domain, TimeVariable\\n    domain = Domain([TimeVariable(\\\"timestamp\\\")])\\n    timestamps = [\\\"2013-03-13 13:13:31\\\", \\\"2014-04-14 14:14:41\\\", \\\"2015-05-15 15:15:51\\\"]\\n    #create a new TimeVariable object\\n    time_var = TimeVariable()\\n    #it's important to parse strings into floats with var.parse(i)\\n    #list(zip(data)) then transforms the list into a 2d list of lists\\n    time_data = Orange.data.Table(domain, list(zip(time_var.parse(i) for i in timestamps)))\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now say you have some original data you want to append your new data to.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"    data = Orange.data.Table.concatenate([original_data, time_data])\\n    Table.save(data, \\\"data.tab\\\")\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"But what if you want to select only a few attributes from the original data? It can be arranged.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"    original_data = Orange.data.Table(\\\"original_data.tab\\\")\\n    new_domain = Domain([\\\"attribute_1\\\", \\\"attribute_2\\\"], source=original_data.domain)\\n    new_data = Orange.data.Table(new_domain, original_data)\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Then concatenate again:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"    data = Orange.data.Table.concatenate([new_data, time_data])\\n    Table.save(data, \\\"selected_data.tab\\\")\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Remember, if your data has string variables, they will always be in meta attributes.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"    domain = Domain([\\\"some_attribute1\\\", \\\"other_attribute2\\\"], metas=[\\\"some_string_variable\\\"])\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Have fun scripting!\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"scripting-with-time-variable"},"buildId":"k-9TZ-ZrkQDGbtdjjI5V3","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>