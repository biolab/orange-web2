<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-45fae5f2ec2ec297.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-abafce5311b78c60.js" defer=""></script><script src="/_next/static/chunks/pages/_app-463eea64dd46fd78.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-9737114052c0c44f.js" defer=""></script><script src="/_next/static/Pq4MTEXwxi3akD3CFvrRB/_buildManifest.js" defer=""></script><script src="/_next/static/Pq4MTEXwxi3akD3CFvrRB/_ssgManifest.js" defer=""></script></head><body><div id="__next"><nav class="navbar__Nav-sc-q11qw3-0 hZTkcw"><ul><a href="/blog">Blog</a></ul><button class="navbar__Burger-sc-q11qw3-1 cGMLJw">X</button></nav><main><div class="slug__Wrapper-sc-1xtdpf8-0 cHTstd"><h1>Paint Your Data</h1><p>One of the widgets I enjoy very much when teaching introductory course in data mining is the <a href="/widget-catalog/data/paintdata/">Paint Data</a> widget. When painting in this widget I would intentionally include some clusters, or intentionally obscure them. Or draw them in any strange shape. Then I would discuss with students if these clusters are identified by <a href="/widget-catalog/unsupervised/kmeans/">k-means clustering</a> or by hierarchical clustering. We would also discuss automatic scoring of the quality of clusters, come up with the idea of a <a href="http://en.wikipedia.org/wiki/Silhouette_(clustering)">silhouette</a> (ok, already invented, but helps if you get this idea on your own as well). And then we would play with various data sets and clustering techniques and their parameters in Orange.</p>
<p>Like in the following workflow where I drew three clusters which were indeed recognized by <a href="/widget-catalog/unsupervised/kmeans/">k-means clustering</a>. Notice that silhouette scoring correctly identified even the number of clusters. And I also drew the clustered data in the Scatterplot to check if the clusters are indeed where they should be.</p>
<p><img src="/blog/2013-12-paint-your-data/paintdata-k-means-ok_1.png__600x1000_q95_upscale.png" alt=""/></p>
<p>Or like in the workflow below where k-means fails miserably (but someother clustering technique would not).</p>
<p><img src="/blog/2013-12-paint-your-data/paintdata-k-means-notok.png__600x1000_q95_upscale.jpg" alt=""/></p>
<p><a href="/widget-catalog/data/paintdata/">Paint Data</a> can also be used in supervised setting, for classification tasks. We can set the intended number of classes, and then chose any of these to paint the data. Below I have used it to create the datasets to check the behavior of several classifiers.</p>
<p><img src="/blog/2013-12-paint-your-data/paintdata-supervised_1.png__600x1000_q95_upscale.png" alt=""/></p>
<p>There are tons of other workflows where <a href="/widget-catalog/data/paintdata/">Paint Data</a> can be useful. Give it a try!</p></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"frontmatter":{"author":"BIOLAB","date":"2013-12-20 20:19:00+00:00","draft":false,"title":"Paint Your Data","type":"blog","blog":["data","visualization"]},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    img: \"img\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"One of the widgets I enjoy very much when teaching introductory course in data mining is the \", _jsx(_components.a, {\n        href: \"/widget-catalog/data/paintdata/\",\n        children: \"Paint Data\"\n      }), \" widget. When painting in this widget I would intentionally include some clusters, or intentionally obscure them. Or draw them in any strange shape. Then I would discuss with students if these clusters are identified by \", _jsx(_components.a, {\n        href: \"/widget-catalog/unsupervised/kmeans/\",\n        children: \"k-means clustering\"\n      }), \" or by hierarchical clustering. We would also discuss automatic scoring of the quality of clusters, come up with the idea of a \", _jsx(_components.a, {\n        href: \"http://en.wikipedia.org/wiki/Silhouette_(clustering)\",\n        children: \"silhouette\"\n      }), \" (ok, already invented, but helps if you get this idea on your own as well). And then we would play with various data sets and clustering techniques and their parameters in Orange.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Like in the following workflow where I drew three clusters which were indeed recognized by \", _jsx(_components.a, {\n        href: \"/widget-catalog/unsupervised/kmeans/\",\n        children: \"k-means clustering\"\n      }), \". Notice that silhouette scoring correctly identified even the number of clusters. And I also drew the clustered data in the Scatterplot to check if the clusters are indeed where they should be.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/blog/2013-12-paint-your-data/paintdata-k-means-ok_1.png__600x1000_q95_upscale.png\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Or like in the workflow below where k-means fails miserably (but someother clustering technique would not).\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/blog/2013-12-paint-your-data/paintdata-k-means-notok.png__600x1000_q95_upscale.jpg\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.a, {\n        href: \"/widget-catalog/data/paintdata/\",\n        children: \"Paint Data\"\n      }), \" can also be used in supervised setting, for classification tasks. We can set the intended number of classes, and then chose any of these to paint the data. Below I have used it to create the datasets to check the behavior of several classifiers.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/blog/2013-12-paint-your-data/paintdata-supervised_1.png__600x1000_q95_upscale.png\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"There are tons of other workflows where \", _jsx(_components.a, {\n        href: \"/widget-catalog/data/paintdata/\",\n        children: \"Paint Data\"\n      }), \" can be useful. Give it a try!\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"paint-your-data"},"buildId":"Pq4MTEXwxi3akD3CFvrRB","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>