<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Orange Data Mining</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/media/0ac14a3c407fb3c4-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/fc6fba7ce0876fef-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/3cc61a2a1d48cb85-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/css/b49f75c2c957040b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b49f75c2c957040b.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-880e48e2fc817058.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-321f842b3cd96ae0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-47d609e9b36d003a.js" defer=""></script><script src="/_next/static/chunks/pages/examples-df5f625c44978e82.js" defer=""></script><script src="/_next/static/seFQNhsTJmNgapBdo_31b/_buildManifest.js" defer=""></script><script src="/_next/static/seFQNhsTJmNgapBdo_31b/_ssgManifest.js" defer=""></script><style data-styled="" data-styled-version="5.3.6">.iSNtvJ{position:relative;max-width:1296px;margin-right:auto;margin-left:auto;padding-left:72px;padding-right:72px;height:100%;box-sizing:content-box;}/*!sc*/
@media (max-width:1130px){.iSNtvJ{padding-left:30px;padding-right:30px;}}/*!sc*/
@media (max-width:720px){.iSNtvJ{padding-left:15px;padding-right:15px;}}/*!sc*/
.lcUshn{position:relative;max-width:1296px;margin-right:auto;margin-left:auto;padding-left:72px;padding-right:72px;height:100%;box-sizing:content-box;margin-top:80px;margin-bottom:80px;}/*!sc*/
@media (max-width:1130px){.lcUshn{padding-left:30px;padding-right:30px;}}/*!sc*/
@media (max-width:720px){.lcUshn{padding-left:15px;padding-right:15px;}}/*!sc*/
@media (max-width:920px){.lcUshn{margin-top:60px;}}/*!sc*/
@media (max-width:720px){.lcUshn{margin-top:40px;}}/*!sc*/
@media (max-width:920px){.lcUshn{margin-bottom:60px;}}/*!sc*/
data-styled.g1[id="sc-ef15f394-0"]{content:"iSNtvJ,lcUshn,"}/*!sc*/
.fYoBKL{position:relative;display:inline-block;max-width:100%;font-size:20px;line-height:1.25;font-weight:600;-webkit-text-decoration:none;text-decoration:none;color:#fff;padding:10px 15px;border-radius:5px;background-image:linear-gradient(180deg,#FE7A00 74.93%,#F65D18 100%);box-shadow:0px 10px 10px rgba(0,0,0,0.03);background-size:100%;cursor:pointer;z-index:2;}/*!sc*/
.fYoBKL:before{content:"";display:block;position:absolute;top:0;left:0;width:100%;height:100%;border-radius:inherit;background-image:linear-gradient(180deg,#ffbc44 100%,#FE7A00 100%);opacity:0;z-index:-100;-webkit-transition:opacity 0.45s;transition:opacity 0.45s;}/*!sc*/
.fYoBKL:hover{color:#fff;}/*!sc*/
.fYoBKL:hover:before{opacity:1;}/*!sc*/
data-styled.g2[id="sc-e429b959-0"]{content:"fYoBKL,"}/*!sc*/
.ikuqzB{background:#1F1F1F;padding:38px 0 25px;color:#fff;}/*!sc*/
data-styled.g3[id="sc-7afe78da-0"]{content:"ikuqzB,"}/*!sc*/
.hrSlzr{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-column-gap:80px;column-gap:80px;row-gap:40px;margin-bottom:40px;}/*!sc*/
.hrSlzr h3{font-size:16px;font-weight:600;margin-bottom:12px;}/*!sc*/
.hrSlzr li + li{margin-top:12px;}/*!sc*/
data-styled.g4[id="sc-7afe78da-1"]{content:"hrSlzr,"}/*!sc*/
.eWdALT{display:none;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:space-around;-webkit-justify-content:space-around;-ms-flex-pack:space-around;justify-content:space-around;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;width:44px;height:34px;padding:6px;border-radius:5px;border:none;background:linear-gradient(180deg,#FE7A00 74.93%,#F65D18 100%);box-shadow:0px 10px 10px rgba(0,0,0,0.03);cursor:pointer;margin-left:auto;}/*!sc*/
@media (max-width:920px){.eWdALT{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;}}/*!sc*/
.eWdALT div{width:22px;height:2px;background:#fff;-webkit-transform-origin:1px;-ms-transform-origin:1px;transform-origin:1px;-webkit-transition:all 0.3s linear;transition:all 0.3s linear;}/*!sc*/
data-styled.g5[id="sc-46d6b9d9-0"]{content:"eWdALT,"}/*!sc*/
.jTcDmc{-webkit-clip:rect(0 0 0 0);clip:rect(0 0 0 0);-webkit-clip-path:inset(50%);clip-path:inset(50%);height:1px;overflow:hidden;position:absolute;white-space:nowrap;width:1px;}/*!sc*/
data-styled.g6[id="sc-cdea7863-0"]{content:"jTcDmc,"}/*!sc*/
.gPgccM{position:fixed;top:0;left:0;width:100%;height:80px;z-index:5;background:#fff;box-shadow:0px 4px 10px 4px rgba(0,0,0,0.04);}/*!sc*/
data-styled.g7[id="sc-6852f5f6-0"]{content:"gPgccM,"}/*!sc*/
.jrLPNu{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;height:100%;}/*!sc*/
.jrLPNu .img-logo{width:115px;}/*!sc*/
data-styled.g8[id="sc-6852f5f6-1"]{content:"jrLPNu,"}/*!sc*/
.hzGhxs{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}/*!sc*/
@media (max-width:920px){.hzGhxs{display:block;position:absolute;top:80px;left:0;width:100%;z-index:1;padding:0 30px 30px;background-color:#fff;opacity:0;z-index:-9999;pointer-events:none;-webkit-transition:opacity 0.3s ease;transition:opacity 0.3s ease;box-shadow:0 4px 10px -1px rgba(0,0,0,0.04);}}/*!sc*/
@media (max-width:720px){.hzGhxs{padding:0 15px 15px;}}/*!sc*/
data-styled.g9[id="sc-6852f5f6-2"]{content:"hzGhxs,"}/*!sc*/
.chSgxF{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}/*!sc*/
@media (max-width:920px){.chSgxF{display:block;margin-bottom:15px;}}/*!sc*/
.chSgxF li + li{margin-left:26px;}/*!sc*/
@media (max-width:920px){.chSgxF li + li{margin-left:0;}}/*!sc*/
.chSgxF a{display:inline-block;font-size:1.25rem;line-height:1;color:#000000;-webkit-text-decoration:none;text-decoration:none;-webkit-transition:color 0.3s;transition:color 0.3s;}/*!sc*/
.chSgxF a:hover{color:#FE7A00;}/*!sc*/
@media (max-width:920px){.chSgxF a{padding:8px 0;}}/*!sc*/
data-styled.g10[id="sc-6852f5f6-3"]{content:"chSgxF,"}/*!sc*/
.hTbjmy{position:relative;width:160px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-transition:width 0.3s ease-in-out;transition:width 0.3s ease-in-out;margin-left:26px;}/*!sc*/
@media (max-width:920px){.hTbjmy{width:auto;margin-left:0;}}/*!sc*/
data-styled.g11[id="sc-6852f5f6-4"]{content:"hTbjmy,"}/*!sc*/
.kzOElI{display:inline-block;position:absolute;top:0;right:42px;width:calc(100% - 42px);height:100%;font-size:16px;line-height:1.25;padding:10px 13px;background:#fff;border-radius:5px 0px 0px 5px;border:1px solid #D9D9D9;border-right:none;-webkit-transition:width 0.3s ease-in-out;transition:width 0.3s ease-in-out;}/*!sc*/
@media (max-width:920px){.kzOElI{display:none;}}/*!sc*/
.kzOElI::-webkit-input-placeholder{color:#D9D9D9;}/*!sc*/
.kzOElI::-moz-placeholder{color:#D9D9D9;}/*!sc*/
.kzOElI:-ms-input-placeholder{color:#D9D9D9;}/*!sc*/
.kzOElI::placeholder{color:#D9D9D9;}/*!sc*/
data-styled.g12[id="sc-6852f5f6-5"]{content:"kzOElI,"}/*!sc*/
.dSfmcG{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;color:#fff;margin-left:auto;-webkit-flex:0 0 42px;-ms-flex:0 0 42px;flex:0 0 42px;height:41px;border:1px solid #474747;border-radius:0px 5px 5px 0px;background-color:#474747;}/*!sc*/
@media (max-width:920px){.dSfmcG{margin-left:0;}}/*!sc*/
data-styled.g13[id="sc-6852f5f6-6"]{content:"dSfmcG,"}/*!sc*/
*,*:before,*:after{box-sizing:border-box;-webkit-font-smoothing:antialiased;}/*!sc*/
html,body{height:100%;margin:0;}/*!sc*/
html{font-family:'Source Sans Pro',sans-serif;font-weight:400;color:#000000;}/*!sc*/
body{background:#fff;}/*!sc*/
body,h1,h2,h3,h4,h5,h6,p,ol,ul{margin:0;padding:0;font-weight:normal;}/*!sc*/
main{padding-top:80px;}/*!sc*/
ol,ul{list-style:none;}/*!sc*/
figure{margin:0;}/*!sc*/
img,video{display:block;max-width:100%;height:auto;}/*!sc*/
a{color:unset;-webkit-text-decoration:none;text-decoration:none;}/*!sc*/
a:hover{color:unset;}/*!sc*/
strong{font-weight:600;}/*!sc*/
pre{display:block;padding:10px 14px;margin:0 0 10px;font-size:18px;line-height:1.42857143;word-break:break-all;word-wrap:break-word;color:#000;background-color:#f5f5f5;border-radius:5px;overflow-x:auto;word-wrap:normal;}/*!sc*/
pre code{padding:0;font-size:inherit;color:inherit;white-space:pre-wrap;background-color:transparent;border-radius:0;}/*!sc*/
code{font-family:Menlo,Monaco,Consolas,"Courier New",monospace;padding:2px 4px;font-size:90%;color:#c7254e;background-color:#f9f2f4;white-space:nowrap;border-radius:4px;white-space:pre-wrap;}/*!sc*/
::selection{background-color:#FE7A00;color:#fff;}/*!sc*/
.lg-container .lg-backdrop.in{opacity:0.75;}/*!sc*/
.lg-container .lg-toolbar.lg-group,.lg-container .lg-outer .lg-thumb-outer{background:rgba(0,0,0,0.45);}/*!sc*/
data-styled.g18[id="sc-global-exMkeD1"]{content:"sc-global-exMkeD1,"}/*!sc*/
.jvjDgd{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;padding:30px 0;border-top:1px solid #D9D9D9;}/*!sc*/
data-styled.g30[id="sc-7a153437-0"]{content:"jvjDgd,"}/*!sc*/
.buRwwf{font-size:16px;line-height:1.25;color:#1F1F1F;padding:0;border:0;width:30px;height:30px;background-color:transparent;border-radius:4px;cursor:pointer;color:#fff;background-color:#5651EC;}/*!sc*/
.dvafcB{font-size:16px;line-height:1.25;color:#1F1F1F;padding:0;border:0;width:30px;height:30px;background-color:transparent;border-radius:4px;cursor:pointer;}/*!sc*/
data-styled.g31[id="sc-7a153437-1"]{content:"buRwwf,dvafcB,"}/*!sc*/
.hWuziN{font-size:16px;line-height:1.25;color:#5651EC;padding:3px 5px;border:none;background-color:transparent;cursor:pointer;}/*!sc*/
.hWuziN:hover img{-webkit-transform:translateX(3px);-ms-transform:translateX(3px);transform:translateX(3px);}/*!sc*/
.hWuziN img{display:inline-block;margin:0 4px;-webkit-transition:-webkit-transform 0.3s;-webkit-transition:transform 0.3s;transition:transform 0.3s;}/*!sc*/
data-styled.g32[id="sc-7a153437-2"]{content:"hWuziN,"}/*!sc*/
.cKaKhB{font-size:16px;font-weight:600;color:#5651EC;margin-bottom:6px;text-transform:capitalize;}/*!sc*/
data-styled.g36[id="sc-cb616f43-3"]{content:"cKaKhB,"}/*!sc*/
.dWjScU{font-size:44px;line-height:1.13;font-weight:700;color:#1F1F1F;margin-bottom:12px;}/*!sc*/
.dWjScU a{-webkit-transition:color 0.3s;transition:color 0.3s;}/*!sc*/
.dWjScU a:hover{color:#FE7A00;}/*!sc*/
data-styled.g40[id="sc-fd3c9e39-0"]{content:"dWjScU,"}/*!sc*/
.haHtPX{margin-bottom:50px;text-align:center;}/*!sc*/
data-styled.g43[id="sc-5473ca07-0"]{content:"haHtPX,"}/*!sc*/
.dbZLGZ{padding:4px 8px;font-size:16px;background:#fff;border-radius:5px;border:1px solid #5651EC;color:#5651EC;cursor:pointer;}/*!sc*/
data-styled.g44[id="sc-5b4f5cc1-0"]{content:"dbZLGZ,"}/*!sc*/
.hvTfLC{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;gap:8px;padding-bottom:23px;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;}/*!sc*/
data-styled.g45[id="sc-889b783c-0"]{content:"hvTfLC,"}/*!sc*/
.cOjpEM{padding-top:30px;border-top:1px solid #D9D9D9;}/*!sc*/
data-styled.g52[id="sc-ba01fcc0-0"]{content:"cOjpEM,"}/*!sc*/
.kycIDx p{font-size:20px;-webkit-letter-spacing:0.2px;-moz-letter-spacing:0.2px;-ms-letter-spacing:0.2px;letter-spacing:0.2px;}/*!sc*/
data-styled.g53[id="sc-ba01fcc0-1"]{content:"kycIDx,"}/*!sc*/
.kzLJy{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;gap:60px;}/*!sc*/
@media (max-width:920px){.kzLJy{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;gap:30px;}}/*!sc*/
.kzLJy h2{font-size:34px;font-weight:700;margin-bottom:10px;}/*!sc*/
.kzLJy a{margin-top:30px;}/*!sc*/
.sc-ba01fcc0-2 + .sc-ba01fcc0-2{margin-top:130px;}/*!sc*/
.kzLJy img{width:250px;}/*!sc*/
data-styled.g54[id="sc-ba01fcc0-2"]{content:"kzLJy,"}/*!sc*/
.iuEBBQ{-webkit-flex:20;-ms-flex:20;flex:20;}/*!sc*/
data-styled.g55[id="sc-ba01fcc0-3"]{content:"iuEBBQ,"}/*!sc*/
.guWFuM{-webkit-flex:30;-ms-flex:30;flex:30;}/*!sc*/
.guWFuM img{width:100%;}/*!sc*/
data-styled.g56[id="sc-ba01fcc0-4"]{content:"guWFuM,"}/*!sc*/
</style></head><body><div id="__next"><div class="__className_ac89ad"><nav class="sc-6852f5f6-0 gPgccM"><div class="sc-ef15f394-0 iSNtvJ"><div class="sc-6852f5f6-1 jrLPNu"><a href="/"><img alt="Orange Logo" loading="lazy" width="120" height="35" decoding="async" data-nimg="1" class="img-logo" style="color:transparent" src="/_next/static/media/logo-orange.faff1861.svg"/></a><div><button aria-label="Toggle navigation" class="sc-46d6b9d9-0 eWdALT"><div></div><div></div><div></div></button><div class="sc-6852f5f6-2 hzGhxs"><ul class="sc-6852f5f6-3 chSgxF"><li><a href="/examples">Examples</a></li><li><a href="/download">Download</a></li><li><a href="/blog">Blog</a></li><li><a href="/docs">Docs</a></li><li><a href="/workshops">Workshops</a></li></ul><form class="sc-6852f5f6-4 hTbjmy"><div class="sc-6852f5f6-5 kzOElI">Search</div><button class="sc-6852f5f6-6 dSfmcG"><img alt="Icon for search" loading="lazy" width="18" height="17" decoding="async" data-nimg="1" style="color:transparent" src="/_next/static/media/icon-search.459b2665.svg"/><span class="sc-cdea7863-0 jTcDmc">Search through page</span></button></form></div></div></div></div></nav><main><div class="sc-ef15f394-0 lcUshn"><h1 class="sc-fd3c9e39-0 sc-5473ca07-0 dWjScU haHtPX"> <!-- -->Examples</h1><div class="sc-889b783c-0 hvTfLC"><button class="sc-5b4f5cc1-0 dbZLGZ">Text Mining</button><button class="sc-5b4f5cc1-0 dbZLGZ">Survival Analysis</button><button class="sc-5b4f5cc1-0 dbZLGZ">Classification</button><button class="sc-5b4f5cc1-0 dbZLGZ">Clustering</button><button class="sc-5b4f5cc1-0 dbZLGZ">Hierarchical Clustering</button><button class="sc-5b4f5cc1-0 dbZLGZ">Cox Regression</button><button class="sc-5b4f5cc1-0 dbZLGZ">Scatter Plot</button><button class="sc-5b4f5cc1-0 dbZLGZ">Visualization</button><button class="sc-5b4f5cc1-0 dbZLGZ">Cross Validation</button><button class="sc-5b4f5cc1-0 dbZLGZ">Box Plot</button></div><ul class="sc-ba01fcc0-0 cOjpEM"><li class="sc-ba01fcc0-2 kzLJy"><div class="sc-ba01fcc0-3 iuEBBQ"><p class="sc-cb616f43-3 cKaKhB"><span><span>Survival Analysis</span>, </span><span><span>Cox Regression</span>, </span><span><span>Concordance Index</span>, </span><span><span>Cross Validation</span></span></p><h2>Cross Validation for Survival Models</h2><div class="sc-ba01fcc0-1 kycIDx"><p>Orange built-in methods for testing and scoring the predictive models now support survival-related models like Cox regression. Here we demonstrate cross-validation to estimate the concordance index for the Cox regression model trained on data instances from selected features.</p></div><a href="https://download.biolab.si/download/files/workflows/orange/730_c_index_cross_validation.ows" class="sc-e429b959-0 fYoBKL">Download</a></div><div class="sc-ba01fcc0-4 guWFuM"><img alt="" loading="lazy" width="487" height="343" decoding="async" data-nimg="1" style="color:transparent" src="/examples/c-index-cross-validation/730_c_index_cross_validation.webp"/></div></li><li class="sc-ba01fcc0-2 kzLJy"><div class="sc-ba01fcc0-3 iuEBBQ"><p class="sc-cb616f43-3 cKaKhB"><span><span>Clustering</span>, </span><span><span>Hierarchical Clustering</span>, </span><span><span>Box Plot</span></span></p><h2>Cluster Inspection</h2><div class="sc-ba01fcc0-1 kycIDx"><p>We use the zoo data set in combination with Hierarchical Clustering to discover groups of animals. Now that we have the clusters we want to find out what is significant for each cluster! Pass the clusters to Box Plot and use &#x27;Order by relevance&#x27; to discover what defines a cluster. Seems like they are well-separated by the type, even though the clustering was unaware of the class label!</p></div><a href="https://download.biolab.si/download/files/workflows/orange/315-cluster-inspection.ows" class="sc-e429b959-0 fYoBKL">Download</a></div><div class="sc-ba01fcc0-4 guWFuM"><img alt="" loading="lazy" width="1380" height="840" decoding="async" data-nimg="1" style="color:transparent" src="/examples/cluster-inspection/cluster-inspection.webp"/></div></li><li class="sc-ba01fcc0-2 kzLJy"><div class="sc-ba01fcc0-3 iuEBBQ"><p class="sc-cb616f43-3 cKaKhB"><span><span>Survival Analysis</span>, </span><span><span>Kaplan-Meier</span>, </span><span><span>Cox Regression</span></span></p><h2>Cohort Construction and Validation</h2><div class="sc-ba01fcc0-1 kycIDx"><p>Stratification of patients into low and high-risk groups is a common task in survival analysis to identify clinical and biological factors that contribute to survival. One approach to stratification is by computing risk score values based on the Cox regression model. With the clever use of Orange widgets, we can split the data into training and validation sets and then interactively generate risk score models on training data to observe the difference in cohorts&#x27; survival rate on training and validation samples side-by-side. Read more on how <a href="blog/why-you-should-use-apply-domain">Apply domain</a> enables this kind of workflows.</p></div><a href="https://download.biolab.si/download/files/workflows/orange/720_cohort_construction_and_validation.ows" class="sc-e429b959-0 fYoBKL">Download</a></div><div class="sc-ba01fcc0-4 guWFuM"><img alt="" loading="lazy" width="1796" height="686" decoding="async" data-nimg="1" style="color:transparent" src="/examples/cohort-construction-and-validation/720_cohort_construction_and_validation.webp"/></div></li><li class="sc-ba01fcc0-2 kzLJy"><div class="sc-ba01fcc0-3 iuEBBQ"><p class="sc-cb616f43-3 cKaKhB"><span><span>Cross Validation</span>, </span><span><span>Predictive models</span>, </span><span><span>Classification</span></span></p><h2>Cross Validation</h2><div class="sc-ba01fcc0-1 kycIDx"><p>How good are supervised data mining methods on your classification dataset? Here&#x27;s a workflow that scores various classification techniques on a dataset from medicine. The central widget here is the one for testing and scoring, which is given the data and a set of learners, does cross-validation and scores predictive accuracy, and outputs the scores for further examination.</p></div><a href="https://download.biolab.si/download/files/workflows/orange/450-cross-validation.ows" class="sc-e429b959-0 fYoBKL">Download</a></div><div class="sc-ba01fcc0-4 guWFuM"><img alt="" loading="lazy" width="1135" height="691" decoding="async" data-nimg="1" style="color:transparent" src="/examples/cross-validation/cross-validation.webp"/></div></li><li class="sc-ba01fcc0-2 kzLJy"><div class="sc-ba01fcc0-3 iuEBBQ"><p class="sc-cb616f43-3 cKaKhB"><span><span>Classification</span>, </span><span><span>Data Sampler</span>, </span><span><span>Predictive models</span></span></p><h2>Train and Test Data</h2><div class="sc-ba01fcc0-1 kycIDx"><p>In building predictive models it is important to have a separate train and test data sets in order to avoid overfitting and to properly score the models. Here we use Data Sampler to split the data into training and test data, use training data for building a model and, finally, test on test data. Try several other classifiers to see how the scores change.</p></div><a href="https://download.biolab.si/download/files/workflows/orange/420-data-sampler.ows" class="sc-e429b959-0 fYoBKL">Download</a></div><div class="sc-ba01fcc0-4 guWFuM"><img alt="" loading="lazy" width="1637" height="997" decoding="async" data-nimg="1" style="color:transparent" src="/examples/data-sampler/data-sampler.webp"/></div></li></ul><div class="sc-7a153437-0 jvjDgd"><button class="sc-7a153437-1 buRwwf">1</button><button class="sc-7a153437-1 dvafcB">2</button><button class="sc-7a153437-1 dvafcB">3</button><span>...</span><button class="sc-7a153437-1 dvafcB">7</button><button class="sc-7a153437-2 hWuziN">Next<img alt="" loading="lazy" width="7" height="10" decoding="async" data-nimg="1" style="color:transparent" src="/_next/static/media/icon-arrow.a5093233.svg"/></button></div></div></main><footer class="sc-7afe78da-0 ikuqzB"><div class="sc-ef15f394-0 iSNtvJ"><div class="sc-7afe78da-1 hrSlzr"><div><h3>Orange</h3><ul><li><a href="/faq">FAQ</a></li><li><a href="/license">License</a></li><li><a href="/privacy">Privacy</a></li><li><a href="/citation">Citation</a></li><li><a href="/contact">Contact</a></li></ul></div><div><h3>Download</h3><ul><li><a href="/download#win">Windows</a></li><li><a href="/download#mac">Mac OS</a></li></ul></div><div><h3>Community</h3><ul><li><a href="https://twitter.com/OrangeDataMiner">Twitter</a></li><li><a href="https://www.facebook.com/orangedatamining">Facebook</a></li><li><a href="https://datascience.stackexchange.com/questions/tagged/orange">Stack Exchange</a></li><li><a href="https://www.youtube.com/channel/UClKKWBe2SCAEyv7ZNGhIe4g">YouTube</a></li><li><a href="https://discord.com/invite/FWrfeXV">Discord</a></li></ul></div><div><h3>Documentation</h3><ul><li><a href="/getting-started">Get started</a></li><li><a href="/widget-catalogue">Widgets</a></li><li><a href="https://orange3.readthedocs.io/projects/orange-data-mining-library/en/latest/">Scripting</a></li></ul></div><div><h3>Developers</h3><ul><li><a href="https://github.com/biolab/orange3">GitHub</a></li><li><a href="http://docs.biolab.si/3/development/">Getting started</a></li></ul></div><div><a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&amp;hosted_button_id=A76TAX87ZVR3J" target="_blank" rel="noreferrer" class="sc-e429b959-0 fYoBKL">Donate to Orange</a></div></div><p>Copyright Â© University of Ljubljana</p></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"examples":[{"title":"Cross Validation for Survival Models","images":[{"width":487,"height":343,"src":"/examples/c-index-cross-validation/730_c_index_cross_validation.webp"}],"type":"workflows","blog":"","video":"","download":"730_c_index_cross_validation.ows","workflows":["Survival Analysis","Cox Regression","Concordance Index","Cross Validation"],"weight":730,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"Orange built-in methods for testing and scoring the predictive models now support survival-related models like Cox regression. Here we demonstrate cross-validation to estimate the concordance index for the Cox regression model trained on data instances from selected features.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Cluster Inspection","images":[{"width":1380,"height":840,"src":"/examples/cluster-inspection/cluster-inspection.webp"}],"type":"workflows","blog_link":"","video":"","download":"315-cluster-inspection.ows","workflows":["Clustering","Hierarchical Clustering","Box Plot"],"weight":315,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"We use the zoo data set in combination with Hierarchical Clustering to discover groups of animals. Now that we have the clusters we want to find out what is significant for each cluster! Pass the clusters to Box Plot and use 'Order by relevance' to discover what defines a cluster. Seems like they are well-separated by the type, even though the clustering was unaware of the class label!\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Cohort Construction and Validation","images":[{"width":1796,"height":686,"src":"/examples/cohort-construction-and-validation/720_cohort_construction_and_validation.webp"}],"type":"workflows","blog":"","video":"","download":"720_cohort_construction_and_validation.ows","workflows":["Survival Analysis","Kaplan-Meier","Cox Regression"],"weight":720,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_components.p, {\n    children: [\"Stratification of patients into low and high-risk groups is a common task in survival analysis to identify clinical and biological factors that contribute to survival. One approach to stratification is by computing risk score values based on the Cox regression model. With the clever use of Orange widgets, we can split the data into training and validation sets and then interactively generate risk score models on training data to observe the difference in cohorts' survival rate on training and validation samples side-by-side. Read more on how \", _jsx(_components.a, {\n      href: \"blog/why-you-should-use-apply-domain\",\n      children: \"Apply domain\"\n    }), \" enables this kind of workflows.\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Cross Validation","images":[{"width":1135,"height":691,"src":"/examples/cross-validation/cross-validation.webp"}],"type":"workflows","blog_link":"","video":"","download":"450-cross-validation.ows","workflows":["Cross Validation","Predictive models","Classification"],"weight":450,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"How good are supervised data mining methods on your classification dataset? Here's a workflow that scores various classification techniques on a dataset from medicine. The central widget here is the one for testing and scoring, which is given the data and a set of learners, does cross-validation and scores predictive accuracy, and outputs the scores for further examination.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Train and Test Data","images":[{"width":1637,"height":997,"src":"/examples/data-sampler/data-sampler.webp"}],"type":"workflows","blog_link":"","video":"","download":"420-data-sampler.ows","workflows":["Classification","Data Sampler","Predictive models"],"weight":420,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"In building predictive models it is important to have a separate train and test data sets in order to avoid overfitting and to properly score the models. Here we use Data Sampler to split the data into training and test data, use training data for building a model and, finally, test on test data. Try several other classifiers to see how the scores change.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Visalization of Data Subsets","images":[{"width":1316,"height":801,"src":"/examples/data-subsets/scatterplot-visualize-subset.webp"}],"type":"workflows","blog_link":"","video":"","download":"130-scatterplot-visualize-subset.ows","workflows":["Scatter Plot","Visualization"],"weight":130,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"Some visualization widget, like Scatter Plot and several data projection widgets, can expose the data instances in the data subset. In this workflow, Scatter Plot visualizes the data from the input data file, but also marks the data points that have been selected in the Data Table (selected rows).\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Explore Subpopulations with Distinct Risk Profiles","images":[{"width":647,"height":419,"src":"/examples/explore-subpopulations-with-distinct-risk-profiles/740_hierarhical_clustering.webp"}],"type":"workflows","blog":"","video":"","download":"740_hierarhical_clustering.ows","workflows":["Survival Analysis","Clustering","Hierarchical Clustering","Box Plot"],"weight":740,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"We can visualize the difference in subpopulations of breast cancer patients in the METABRIC dataset through clustering, that is, by identifying groups of data instances similar to each other. We can observe the difference in survival rate between clusters with Kaplan-Meier Plot and explore features that characterize patients of each cluster with the Box Plot widget.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Exploring Survival Features","images":[{"width":621,"height":343,"src":"/examples/exploring-survival-features/710_survival_features.webp"}],"type":"workflows","blog":"","video":"","download":"710_survival_features.ows","workflows":["Survival Analysis","Cox Regression"],"weight":710,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"In the workflow, we show how to find and analyze variables related to survival. We start with variables ranked by univariate Cox regression analysis, where we can select the feature of interest. The Distribution widget shows its distribution and allows us to choose interactively a group of patients related to its values. We compare the survival of this group to all other patients in the Kaplan-Meier plot widget.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Feature Ranking","images":[{"width":1196,"height":728,"src":"/examples/feature-ranking/feature-ranking.webp"}],"type":"workflows","blog_link":"","video":"","download":"410-feature-ranking.ows","workflows":["Feature Ranking","Feature Selection"],"weight":410,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"For supervised problems, where data instances are annotated with class labels, we would like to know which are the most informative features. Rank widget provides a table of features and their informativity scores, and supports manual feature selection. In the workflow, we used it to find the best two features (of initial 79 from brown-selected dataset) and display its scatter plot.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"File and Data Table","images":[{"width":1380,"height":840,"src":"/examples/file-and-data-table-widget/file-and-data-table-widget.webp"}],"type":"workflows","blog_link":"","video":"","download":"110-file-and-data-table-widget.ows","workflows":["Data Table","Data Loading"],"weight":120,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"The basic data mining units in Orange are called widgets. In this workflow, the File widget reads the data. File widget communicates this data to Data Table widget that shows the data in a spreadsheet. The output of File is connected to the input of Data Table.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Hierarchical Clustering","images":[{"width":1610,"height":980,"src":"/examples/hierarchical-clustering/hierarchical-clustering.webp"}],"type":"workflows","blog_link":"","video":"","download":"310-clustering.ows","workflows":["Hierarchical Clustering","Clustering"],"weight":310,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"The workflow clusters the data items in iris dataset by first examining the distances between data instances. Distance matrix is passed to Hierarchical Clustering, which renders the dendrogram. Select different parts of the dendrogram to further analyze the corresponding data.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Mental health of tech employees in times of COVID-19","images":[{"width":1372,"height":850,"src":"/examples/mental-health/mental-health.webp"}],"type":"workflows","blog_link":"https://ocean.sagepub.com/blog/mental-health-of-tech-employees-in-times-of-covid-19","video":"","download":"900_mental-health.ows","workflows":["mental health","survey","Hierarchical Clustering"],"weight":900,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_components.p, {\n    children: [\"The COVID-19 pandemic brought about many societal changes, including a serious effect on mental health. The Open Sourcing Mental Health 2021 survey measures attitudes towards mental health in the tech workplace and examines the frequency of mental health disorders among tech workers. The workflow presents how to uncover different types of tech employees based on their responses. The procedure is fully described in the \", _jsx(_components.a, {\n      href: \"https://ocean.sagepub.com/blog/mental-health-of-tech-employees-in-times-of-covid-19\",\n      children: \"SAGE Ocean blog\"\n    }), \".\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Inspecting Outliers with Silhouette","images":[{"width":1329,"height":809,"src":"/examples/outliers/silhouette.webp"}],"type":"workflows","blog_link":"","video":"","download":"260-outliers.ows","workflows":["Silhouette","Outliers","Visualization"],"weight":260,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"Silhouette Plot shows how 'well-centered' each data instance is with respect to its cluster or class label. In this workflow we use iris' class labels to observe which flowers are typical representatives of their class and which are the outliers. Select instances left of zero in the plot and observe which flowers are these. Try connecting the selection with the Scatter Plot to highlight the outliers.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Pivot Table","images":[{"width":1592,"height":969,"src":"/examples/pivot-table/pivot-table.webp"}],"type":"workflows","blog_link":"","video":"","download":"140-pivot-table.ows","workflows":["Data","Pivot Table"],"weight":140,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"Pivot Table can help us aggregate and transform the data. This workflow takes Kickstarter projects and aggregates them by month. We can inspect the frequency of the published projects per month and observe the difference between funded and non-funded projects. Try constructing several tables with pivot and experiment with different aggregation methods.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Principal Component Analysis","images":[{"width":1167,"height":711,"src":"/examples/principal-component-analysis/pca.webp"}],"type":"workflows","blog_link":"","video":"","download":"305-pca.ows","workflows":["PCA","Dimensionality Reduction"],"weight":305,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"PCA transforms the data into a dataset with uncorrelated variables, also called principal components. PCA widget displays a graph (scree diagram) showing a degree of explained variance by best principal components and allows to interactively set the number of components to be included in the output dataset. In this workflow, we can observe the transformation in the Data Table and in Scatter Plot.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Interactive Visualizations","images":[{"width":1241,"height":763,"src":"/examples/scatterplot-data-table/scatterplot-data-table.webp"}],"type":"workflows","blog_link":"","video":"","download":"120-scatterplot-data-table.ows","workflows":["Scatter Plot","Visualization"],"weight":120,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"Most visualizations in Orange are interactive. Scatter Plot for example. Double click its icon to open it and click-and-drag to select a few data points from the plot. Selected data will automatically propagate to Data Table. Double click it to check which data was selected. Change selection and observe the change in the Data Table. This works best if both widgets are open.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Story Arcs","images":[{"width":1278,"height":778,"src":"/examples/story-arcs/story-arcs.webp"}],"type":"workflows","blog_link":"2020/2020-07-27-story-arcs/","video":"","download":"650-story-arcs.ows","workflows":["Text Mining","Timeseries","Sentiment Analysis"],"weight":649,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"In this workflow we explore story arcs in the Little Match Seller story. First we select the story from the corpus of Andersen tales. Then we create a table, where each sentence of the tale is a separate row. We use sentiment analysis to compute the sentiment of each sentence, then observe the emotional arcs through the story. We also inspect sentences with similar scores in the Heat Map and Corpus Viewer.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Survival Curve Estimation","images":[{"width":581,"height":310,"src":"/examples/survival-curve-estimation/700_survival_curve_estimation.webp"}],"type":"workflows","blog":"","video":"","download":"700_survival_curve_estimation.ows","workflows":["Survival Analysis"],"weight":700,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"One of the primary objectives of survival analysis is to estimate the survival probability from observed survival times of different patients. The workflow plots the Kaplan-Meier approximation of the survival curve for the investigated population in the German breast cancer study group. The Kaplan-Meier plot is interactive; we select the longest-surviving patients and use Box Plot to analyze features that best characterize them.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Document Map Annotation","images":[{"width":1606,"height":590,"src":"/examples/text-annotator/text-annotator.webp"}],"type":"workflows","blog_link":"","video":"","download":"text-annotator.ows","workflows":["Text Mining"],"weight":664,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"Documents maps can be enhanced with the keywords annotations. This workflow embeds documents in vector space, computes a t-SNE document map and annotates it. The Annotator widget identifies clusters on the map and annotates them with keywords representing a cluster.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Text Classification","images":[{"width":1748,"height":1064,"src":"/examples/text-classification/text-classification.webp"}],"type":"workflows","blog_link":"","video":"https://youtu.be/zO_zwKZCULo","download":"630-text-classification.ows","workflows":["Text Mining","Classification","Nomogram","Bag of Words"],"weight":630,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"We can use predictive models to classify documents by authorship, their type, sentiment and so on. In this workflow we classify documents by their Aarne-Thompshon-Uther index, that is the defining topic of the tale. We use two simple learners, Logistic Regression and Naive Bayes, both of which can be inspected in the Nomogram.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Text Clustering","images":[{"width":1518,"height":924,"src":"/examples/text-clustering/text-clustering.webp"}],"type":"workflows","blog_link":"","video":"https://youtu.be/rH_vQxQL6oM","download":"620-text-clustering.ows","workflows":["Text Mining","Clustering","Tokenization"],"weight":620,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"The workflow clusters Grimm's tales corpus. We start by preprocessing the data and constructing the bag of words matrix. Then we compute cosine distances between documents and use Hierarchical Clustering, which displays the dendrogram. We observe how well the type of the tale corresponds to the cluster in the MDS.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Corpus and Word Maps","images":[{"width":2226,"height":892,"src":"/examples/text-corpus-and-word-map/text-corpus-and-word-map.webp"}],"type":"workflows","blog_link":"","video":"","download":"text-corpus-and-word-map.ows","workflows":["Text Mining"],"weight":660,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"This workflow shows how to extract the most common words from the documents and observe clusters of semantically similar words with Hierarchical Clustering. We select a group of words (connected to the traffic and roads) and use them to score documents according to selection with the Score Documents widget. The scores are visualized in the document map by the Self-Organizing Maps widget.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Keyword-Based Text Document Scoring","images":[{"width":796,"height":392,"src":"/examples/text-keyword-based-scoring/text-keyword-based-scoring.webp"}],"type":"workflows","blog_link":"","video":"","download":"text-keyword-based-scoring.ows","workflows":["Text Mining"],"weight":658,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"We can score the text documents based on a list of keywords, say, to find the documents which include the keywords or are semantically related to the list of keywords. This workflow shows the Score Documents widget for scoring and the Word List widget to compose a list of keywords. The scores are visualized in the t-SNE document map.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Keyword Extraction from a Set of Text Documents","images":[{"width":587,"height":336,"src":"/examples/text-keyword-extraction/text-keyword-extraction.webp"}],"type":"workflows","blog_link":"","video":"","download":"text-keyword-extraction.ows","workflows":["Text Mining"],"weight":656,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"The Extract Keywords widget can characterize a set of textual documents. In this workflow, we load the documents from the server, preprocess them and embed them in the vector space, and display a semantic document map in the t-SNE widget. In this widget, we can select a set of similar documents and then characterize them through keyword extraction. Extract keywords support different inference techniques, including TF-IDF and deep network-based characterization.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Load Text Corpus from the Server Repository","images":[{"width":553,"height":319,"src":"/examples/text-loading-from-repository/text-loading-from-repository.webp"}],"type":"workflows","blog_link":"","video":"","download":"text-loading-from-repository.ows","workflows":["Text Mining"],"weight":650,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_components.p, {\n    children: [\"The workflow loads the corpus from the \", _jsx(_components.a, {\n      href: \"http://file.biolab.si/text-semantics/data/predlogi-vladi-1k/\",\n      children: \"text repository on the server\"\n    }), \". The repository contains documents with raw text and associated YAML files with meta-features. We here use some pre-processing and then display the most frequent words in a word cloud. This workflow could work on your repository: just change the URL in the Import Documents widget.\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Ontology Generation from Keywords","images":[{"width":1438,"height":534,"src":"/examples/text-ontology/text-ontology.webp"}],"type":"workflows","blog_link":"","video":"","download":"text-ontology.ows","workflows":["Text Mining"],"weight":668,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"We can automatically build the otology from the set of words. In the workflow, we select a group of documents with similar content. From the selected documents, we extract keywords and generate a new ontology from the subset of keywords with the Ontology widget.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Text Preprocessing","images":[{"width":1271,"height":774,"src":"/examples/text-preprocessing/text-preprocessing.webp"}],"type":"workflows","blog_link":"2017/06/19/text-preprocessing/","video":"https://youtu.be/V70UwJZWkZ8","download":"610-text-preprocessing.ows","workflows":["Text Mining","Preprocessing","Tokenization"],"weight":610,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"Text mining requires careful preprocessing. Here's a workflow that uses simple preprocessing for creating tokens from documents. First, it applies lowercase, then splits text into words, and finally, it removes frequent stopwords. Preprocessing is language specific, so change the language to the language of texts where required. Results of preprocessing can be observe in a Word Cloud.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Semantic Document Map","images":[{"width":671,"height":329,"src":"/examples/text-semantic-document-map/text-semantic-document-map.webp"}],"type":"workflows","blog_link":"","video":"","download":"text-semantic-word-map.ows","workflows":["Text Mining"],"weight":652,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"Document maps may reveal clusters of documents with semantically similar content. Here we show a workflow that loads the corpus, performs some text preprocessing and embeds the documents in the vector space using the fastText deep model. The t-SNE widget reveals the document map, where we can select a set of documents and then explore them in Corpus Viewer or characterize them in the display of the most frequent words in the Word Cloud.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Semantic Word Map","images":[{"width":701,"height":395,"src":"/examples/text-semantic-word-map/text-semantic-word-map.webp"},{"width":758,"height":581,"src":"/examples/text-semantic-word-map/text-semantic-word-map-tsne.webp"}],"type":"workflows","blog_link":"","video":"","download":"text-semantic-word-map.ows","workflows":["Text Mining"],"weight":654,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"We can find clusters of semantically related words either by hierarchical clustering or t-SNE visualizations. Here, we show a workflow that loads the documents, extracts frequent words, embeds them in a vector space, and explores word clusters.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Classification Tree","images":[{"width":1437,"height":875,"src":"/examples/tree-scatterplot/tree-scatterplot.webp"}],"type":"workflows","blog_link":"","video":"","download":"250-tree-scatterplot.ows","workflows":["Classification Tree","Classification"],"weight":250,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"This workflow combines the interface and visualization of classification trees with scatter plot. When both the tree viewer and the scatter plot are open, selection of any node of the tree sends the related data instances to scatter plot. In the workflow, the selected data is treated as a subset of the entire dataset and is highlighted in the scatter plot. With simple combination of widgets we have constructed an interactive classification tree browser.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Twitter Data Analysis","images":[{"width":1326,"height":807,"src":"/examples/twitter/twitter.webp"}],"type":"workflows","blog_link":"","video":"https://youtu.be/HDkI6G4slzQ","download":"640-twitter.ows","workflows":["Text Mining","Twitter","Topic Modeling"],"weight":640,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"Tweets are a valuable source of information, for social scientists, marketing managers, linguists, economists, and so on. In this workflow we retrieve data from Twitter, preprocess it, and uncover latent topics with topic modeling. We observe the topics in a Heat Map.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Where Are Misclassifications","images":[{"width":1079,"height":657,"src":"/examples/where-are-misclassifications/misclassifications.webp"}],"type":"workflows","blog_link":"","video":"","download":"470-misclassification-scatterplot.ows","workflows":["Confusion Matrix","Classification","Scatter Plot"],"weight":470,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"Cross-validation of, say, logistic regression can expose the data instances which were misclassified. There are six such instances for iris dataset and ridge-regularized logistic regression. We can select different types of misclassification in Confusion Matrix and highlight them in the Scatter Plot. No surprise: the misclassified instances are close to the class-bordering regions in the scatter plot projection.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}}],"tags":["Text Mining","Survival Analysis","Classification","Clustering","Hierarchical Clustering","Cox Regression","Scatter Plot","Visualization","Cross Validation","Box Plot"]},"__N_SSG":true},"page":"/examples","query":{},"buildId":"seFQNhsTJmNgapBdo_31b","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>