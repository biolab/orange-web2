<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="description" content="Orange Data Mining Toolbox"/><meta property="og:description" content="Orange Data Mining Toolbox"/><meta property="og:url" content="https://orangedatamining.com"/><meta property="og:type" content="website"/><meta property="og:image" content="/_next/static/media/orange-cover.6d606323.png"/><meta property="og:image:width" content="1033"/><meta property="og:image:height" content="626"/><meta property="og:site_name" content="Orange Data Mining"/><meta name="author" content="Bioinformatics Laboratory, University of Ljubljana"/><title>Orange Data Mining - Examples</title><meta name="robots" content="index,follow"/><meta property="og:title" content="Orange Data Mining - Examples"/><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/media/a9b61b60c2d733b4-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/css/2fbd8d191ccf221f.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/2fbd8d191ccf221f.css" crossorigin="" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-21c828b96ad33382.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-0c7baedefba6b077.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-61a1de8ce4711ed8.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-a646f1579d13d30b.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/924-5dfdc5ec90352bcb.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/examples-ed7bf8e316db75cd.js" defer="" crossorigin=""></script><script src="/_next/static/ZuZfkfEcjaJ1Uvd7EKiHp/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/ZuZfkfEcjaJ1Uvd7EKiHp/_ssgManifest.js" defer="" crossorigin=""></script><style data-styled="" data-styled-version="5.3.6">.eVggRJ{max-width:1296px;margin-right:auto;margin-left:auto;padding-left:72px;padding-right:72px;height:100%;box-sizing:content-box;}/*!sc*/
@media (max-width:1130px){.eVggRJ{padding-left:30px;padding-right:30px;}}/*!sc*/
@media (max-width:720px){.eVggRJ{padding-left:15px;padding-right:15px;}}/*!sc*/
.hRMVSr{max-width:1296px;margin-right:auto;margin-left:auto;padding-left:72px;padding-right:72px;height:100%;box-sizing:content-box;margin-top:80px;margin-bottom:80px;}/*!sc*/
@media (max-width:1130px){.hRMVSr{padding-left:30px;padding-right:30px;}}/*!sc*/
@media (max-width:720px){.hRMVSr{padding-left:15px;padding-right:15px;}}/*!sc*/
@media (max-width:920px){.hRMVSr{margin-top:60px;}}/*!sc*/
@media (max-width:720px){.hRMVSr{margin-top:40px;}}/*!sc*/
@media (max-width:920px){.hRMVSr{margin-bottom:60px;}}/*!sc*/
data-styled.g1[id="sc-61db3aea-0"]{content:"eVggRJ,hRMVSr,"}/*!sc*/
.jyxOJT{position:relative;display:inline-block;max-width:100%;font-size:20px;line-height:1.25;font-weight:600;-webkit-text-decoration:none;text-decoration:none;color:#fff;padding:10px 15px;border-radius:5px;background-image:linear-gradient(180deg,#FE7A00 74.93%,#F65D18 100%);box-shadow:0px 10px 10px rgba(0,0,0,0.03);background-size:100%;cursor:pointer;z-index:2;}/*!sc*/
@media (max-width:720px){.jyxOJT{font-size:18px;}}/*!sc*/
.jyxOJT:before{content:"";display:block;position:absolute;top:0;left:0;width:100%;height:100%;border-radius:inherit;background-image:linear-gradient(180deg,#ffbc44 100%,#FE7A00 100%);opacity:0;z-index:-100;-webkit-transition:opacity 0.45s;transition:opacity 0.45s;}/*!sc*/
.jyxOJT:hover{color:#fff;}/*!sc*/
.jyxOJT:hover:before{opacity:1;}/*!sc*/
data-styled.g2[id="sc-b6ea565a-0"]{content:"jyxOJT,"}/*!sc*/
.ioIxRn{background:#1F1F1F;padding:38px 0 25px;color:#fff;}/*!sc*/
data-styled.g3[id="sc-3419d6b6-0"]{content:"ioIxRn,"}/*!sc*/
.iYFXoP{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-column-gap:80px;column-gap:80px;row-gap:40px;margin-bottom:40px;}/*!sc*/
@media (max-width:720px){.iYFXoP{display:grid;grid-template-columns:1fr 1fr;-webkit-column-gap:20px;column-gap:20px;}}/*!sc*/
.iYFXoP h3{font-size:16px;font-weight:600;margin-bottom:12px;}/*!sc*/
.iYFXoP li + li{margin-top:12px;}/*!sc*/
data-styled.g4[id="sc-3419d6b6-1"]{content:"iYFXoP,"}/*!sc*/
.eWdALT{display:none;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:space-around;-webkit-justify-content:space-around;-ms-flex-pack:space-around;justify-content:space-around;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;width:44px;height:34px;padding:6px;border-radius:5px;border:none;background:linear-gradient(180deg,#FE7A00 74.93%,#F65D18 100%);box-shadow:0px 10px 10px rgba(0,0,0,0.03);cursor:pointer;margin-left:auto;}/*!sc*/
@media (max-width:920px){.eWdALT{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;}}/*!sc*/
.eWdALT div{width:22px;height:2px;background:#fff;-webkit-transform-origin:1px;-ms-transform-origin:1px;transform-origin:1px;-webkit-transition:all 0.3s linear;transition:all 0.3s linear;}/*!sc*/
data-styled.g5[id="sc-46d6b9d9-0"]{content:"eWdALT,"}/*!sc*/
.jTcDmc{-webkit-clip:rect(0 0 0 0);clip:rect(0 0 0 0);-webkit-clip-path:inset(50%);clip-path:inset(50%);height:1px;overflow:hidden;position:absolute;white-space:nowrap;width:1px;}/*!sc*/
data-styled.g6[id="sc-cdea7863-0"]{content:"jTcDmc,"}/*!sc*/
.dAXQuQ{z-index:100;height:80px;background:#fff;box-shadow:0px 4px 10px 4px rgba(0,0,0,0.04);}/*!sc*/
data-styled.g7[id="sc-a026f25c-0"]{content:"dAXQuQ,"}/*!sc*/
.gUFsBX{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;height:100%;}/*!sc*/
.gUFsBX .img-logo{width:115px;}/*!sc*/
data-styled.g8[id="sc-a026f25c-1"]{content:"gUFsBX,"}/*!sc*/
.bcvGIl{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}/*!sc*/
@media (max-width:920px){.bcvGIl{display:block;position:absolute;top:80px;left:0;width:100%;z-index:1;padding:0 30px 30px;background-color:#fff;opacity:0;z-index:-9999;pointer-events:none;-webkit-transition:opacity 0.3s ease;transition:opacity 0.3s ease;box-shadow:0 4px 10px -1px rgba(0,0,0,0.04);}}/*!sc*/
@media (max-width:720px){.bcvGIl{padding:0 15px 15px;}}/*!sc*/
data-styled.g9[id="sc-a026f25c-2"]{content:"bcvGIl,"}/*!sc*/
.jjIqRA{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}/*!sc*/
@media (max-width:920px){.jjIqRA{display:block;margin-bottom:15px;}}/*!sc*/
.jjIqRA li + li{margin-left:26px;}/*!sc*/
@media (max-width:920px){.jjIqRA li + li{margin-left:0;}}/*!sc*/
.jjIqRA a{display:inline-block;font-size:1.25rem;line-height:1;color:#000000;-webkit-text-decoration:none;text-decoration:none;-webkit-transition:color 0.3s;transition:color 0.3s;}/*!sc*/
.jjIqRA a:hover{color:#FE7A00;}/*!sc*/
@media (max-width:920px){.jjIqRA a{padding:8px 0;}}/*!sc*/
data-styled.g10[id="sc-a026f25c-3"]{content:"jjIqRA,"}/*!sc*/
.eLPewT{position:relative;width:142px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-transition:width 0.3s ease-in-out;transition:width 0.3s ease-in-out;margin-left:26px;}/*!sc*/
@media (max-width:920px){.eLPewT{width:auto;margin-left:0;}}/*!sc*/
data-styled.g11[id="sc-a026f25c-4"]{content:"eLPewT,"}/*!sc*/
.ipGgXV{display:inline-block;position:absolute;top:0;right:42px;width:calc(100% - 42px);height:100%;font-size:16px;line-height:1.25;padding:10px 13px;background:#fff;border-radius:5px 0px 0px 5px;border:1px solid #D9D9D9;border-right:none;-webkit-transition:width 0.3s ease-in-out;transition:width 0.3s ease-in-out;}/*!sc*/
@media (max-width:920px){.ipGgXV{display:none;}}/*!sc*/
.ipGgXV::-webkit-input-placeholder{color:#D9D9D9;}/*!sc*/
.ipGgXV::-moz-placeholder{color:#D9D9D9;}/*!sc*/
.ipGgXV:-ms-input-placeholder{color:#D9D9D9;}/*!sc*/
.ipGgXV::placeholder{color:#D9D9D9;}/*!sc*/
data-styled.g12[id="sc-a026f25c-5"]{content:"ipGgXV,"}/*!sc*/
.iFVURz{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;color:#fff;margin-left:auto;-webkit-flex:0 0 42px;-ms-flex:0 0 42px;flex:0 0 42px;height:41px;border:1px solid #474747;border-radius:0px 5px 5px 0px;background-color:#474747;}/*!sc*/
@media (max-width:920px){.iFVURz{margin-left:0;}}/*!sc*/
data-styled.g13[id="sc-a026f25c-6"]{content:"iFVURz,"}/*!sc*/
.kOMJoa{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;gap:12px;-webkit-box-pack:end;-webkit-justify-content:flex-end;-ms-flex-pack:end;justify-content:flex-end;}/*!sc*/
data-styled.g18[id="sc-7e1621ad-0"]{content:"kOMJoa,"}/*!sc*/
.kkwPib{position:fixed;bottom:20px;right:20px;padding:20px;z-index:999;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;background:#1F1F1F;color:#fff;border-radius:5px;border:1px solid #D9D9D9;box-shadow:0px 6px 20px 0px rgba(0,0,0,0.06);-webkit-transform:translateY(calc(100% + 100px));-ms-transform:translateY(calc(100% + 100px));transform:translateY(calc(100% + 100px));-webkit-transition:-webkit-transform 0.5s ease-in-out;-webkit-transition:transform 0.5s ease-in-out;transition:transform 0.5s ease-in-out;}/*!sc*/
@media (max-width:720px){.kkwPib{left:10px;right:10px;bottom:10px;}}/*!sc*/
.kkwPib p{margin-bottom:11px;font-size:17px;}/*!sc*/
data-styled.g19[id="sc-7e1621ad-1"]{content:"kkwPib,"}/*!sc*/
.fkWelF{font-size:15px;padding:9px 12px;border-radius:8px;cursor:pointer;background:#1F1F1F;color:#fff;border:1px solid #fff;}/*!sc*/
.dsztgy{font-size:15px;padding:9px 12px;border-radius:8px;cursor:pointer;background:#fff;color:#1F1F1F;border:1px solid #fff;padding-left:22px;padding-right:22px;}/*!sc*/
data-styled.g20[id="sc-7e1621ad-2"]{content:"fkWelF,dsztgy,"}/*!sc*/
.eWBvvS{min-height:100vh;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}/*!sc*/
data-styled.g21[id="sc-b34fb00f-0"]{content:"eWBvvS,"}/*!sc*/
*,*:before,*:after{box-sizing:border-box;-webkit-font-smoothing:antialiased;}/*!sc*/
html,body{height:100%;margin:0;}/*!sc*/
html{font-family:'Source Sans Pro',sans-serif;font-weight:400;color:#000000;}/*!sc*/
body{background:#fff;}/*!sc*/
body,h1,h2,h3,h4,h5,h6,p,ol,ul{margin:0;padding:0;font-weight:normal;}/*!sc*/
main{-webkit-flex:1;-ms-flex:1;flex:1;}/*!sc*/
ol,ul{list-style:none;}/*!sc*/
figure{margin:0;}/*!sc*/
img,video{display:block;max-width:100%;height:auto;}/*!sc*/
a{color:unset;-webkit-text-decoration:none;text-decoration:none;}/*!sc*/
a:hover{color:unset;}/*!sc*/
strong{font-weight:600;}/*!sc*/
pre{display:block;padding:15px;margin:0 0 10px;font-size:14px;word-break:break-all;word-wrap:break-word;color:#000;border:1px solid #ebebeb;border-radius:5px;overflow-x:auto;word-wrap:normal;}/*!sc*/
pre code{padding:0 !important;font-size:inherit;color:inherit;white-space:pre-wrap;background-color:transparent;border-radius:0;border:none;line-height:1.35;}/*!sc*/
code{padding:2px 3px;background:#f7f7f7;border:1px solid #ededed;border-radius:0.375rem;display:inline-block;line-height:1.2;margin:0;font-size:78%;}/*!sc*/
::selection{background-color:#FE7A00;color:#fff;}/*!sc*/
.lg-container .lg-backdrop.in{opacity:0.75;}/*!sc*/
.lg-container .lg-toolbar.lg-group,.lg-container .lg-outer .lg-thumb-outer{background:rgba(0,0,0,0.45);}/*!sc*/
pre code.hljs{display:block;overflow-x:auto;padding:1em;}/*!sc*/
code.hljs{padding:3px 5px;}/*!sc*/
.hljs{color:#24292e;background:#fff;}/*!sc*/
.hljs-doctag,.hljs-keyword,.hljs-meta .hljs-keyword,.hljs-template-tag,.hljs-template-variable,.hljs-type,.hljs-variable.language_{color:#d73a49;}/*!sc*/
.hljs-title,.hljs-title.class_,.hljs-title.class_.inherited__,.hljs-title.function_{color:#6f42c1;}/*!sc*/
.hljs-attr,.hljs-attribute,.hljs-literal,.hljs-meta,.hljs-number,.hljs-operator,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id,.hljs-variable{color:#005cc5;}/*!sc*/
.hljs-meta .hljs-string,.hljs-regexp,.hljs-string{color:#032f62;}/*!sc*/
.hljs-built_in,.hljs-symbol{color:#e36209;}/*!sc*/
.hljs-code,.hljs-comment,.hljs-formula{color:#6a737d;}/*!sc*/
.hljs-name,.hljs-quote,.hljs-selector-pseudo,.hljs-selector-tag{color:#22863a;}/*!sc*/
.hljs-subst{color:#24292e;}/*!sc*/
.hljs-section{color:#005cc5;font-weight:700;}/*!sc*/
.hljs-bullet{color:#735c0f;}/*!sc*/
.hljs-emphasis{color:#24292e;font-style:italic;}/*!sc*/
.hljs-strong{color:#24292e;font-weight:700;}/*!sc*/
.hljs-addition{color:#22863a;background-color:#f0fff4;}/*!sc*/
.hljs-deletion{color:#b31d28;background-color:#ffeef0;}/*!sc*/
data-styled.g22[id="sc-global-ehweHW1"]{content:"sc-global-ehweHW1,"}/*!sc*/
.iNzSUu{font-size:44px;line-height:1.13;font-weight:700;color:#1F1F1F;margin-bottom:12px;}/*!sc*/
.iNzSUu a{-webkit-transition:color 0.3s;transition:color 0.3s;}/*!sc*/
.iNzSUu a:hover{color:#FE7A00;}/*!sc*/
data-styled.g23[id="sc-89e95305-0"]{content:"iNzSUu,"}/*!sc*/
.dXFGRw{margin-bottom:50px !important;text-align:center;}/*!sc*/
data-styled.g26[id="sc-ba990baf-0"]{content:"dXFGRw,"}/*!sc*/
.bdlyrE{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;padding:30px 0;border-top:1px solid #D9D9D9;}/*!sc*/
data-styled.g27[id="sc-a2f31186-0"]{content:"bdlyrE,"}/*!sc*/
.jQYhVi{font-size:16px;line-height:1.25;color:#1F1F1F;padding:0;border:0;width:32px;height:32px;background-color:transparent;border-radius:4px;cursor:pointer;color:#fff;background-color:#5651EC;}/*!sc*/
.ewzjsY{font-size:16px;line-height:1.25;color:#1F1F1F;padding:0;border:0;width:32px;height:32px;background-color:transparent;border-radius:4px;cursor:pointer;}/*!sc*/
data-styled.g28[id="sc-a2f31186-1"]{content:"jQYhVi,ewzjsY,"}/*!sc*/
.fQlHUc{font-size:16px;line-height:1.25;color:#5651EC;padding:6px 5px;min-width:32px;border:none;background-color:transparent;cursor:pointer;}/*!sc*/
@media (max-width:480px){.fQlHUc span{display:none;}}/*!sc*/
.fQlHUc:hover img{-webkit-transform:translateX(3px);-ms-transform:translateX(3px);transform:translateX(3px);}/*!sc*/
.fQlHUc img{display:inline-block;margin:0 4px;-webkit-transition:-webkit-transform 0.3s;-webkit-transition:transform 0.3s;transition:transform 0.3s;}/*!sc*/
data-styled.g29[id="sc-a2f31186-2"]{content:"fQlHUc,"}/*!sc*/
.gRZIks{font-size:16px;font-weight:600;color:#5651EC;margin-bottom:6px;text-transform:capitalize;}/*!sc*/
.gRZIks span{cursor:pointer;}/*!sc*/
data-styled.g33[id="sc-3c206b28-3"]{content:"gRZIks,"}/*!sc*/
.gTOGMU{padding:4px 8px;font-size:16px;background:#fff;border-radius:5px;border:1px solid #5651EC;color:#5651EC;cursor:pointer;text-transform:capitalize;}/*!sc*/
data-styled.g37[id="sc-d3c41432-0"]{content:"gTOGMU,"}/*!sc*/
.hvTfLC{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;gap:8px;padding-bottom:23px;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;}/*!sc*/
data-styled.g38[id="sc-889b783c-0"]{content:"hvTfLC,"}/*!sc*/
.ENlF{padding-top:30px;border-top:1px solid #D9D9D9;}/*!sc*/
data-styled.g96[id="sc-9e4f7d84-0"]{content:"ENlF,"}/*!sc*/
.gEwLqo p{font-size:20px;-webkit-letter-spacing:0.2px;-moz-letter-spacing:0.2px;-ms-letter-spacing:0.2px;letter-spacing:0.2px;}/*!sc*/
data-styled.g97[id="sc-9e4f7d84-1"]{content:"gEwLqo,"}/*!sc*/
.jLRiqb{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;gap:60px;}/*!sc*/
@media (max-width:920px){.jLRiqb{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;gap:30px;}}/*!sc*/
.jLRiqb h2{font-size:34px;font-weight:700;margin-bottom:10px;}/*!sc*/
.jLRiqb a{margin-top:30px;}/*!sc*/
.sc-9e4f7d84-2 + .sc-9e4f7d84-2{margin-top:130px;}/*!sc*/
.jLRiqb img{width:250px;}/*!sc*/
data-styled.g98[id="sc-9e4f7d84-2"]{content:"jLRiqb,"}/*!sc*/
.bVdaXF{-webkit-flex:20;-ms-flex:20;flex:20;}/*!sc*/
data-styled.g99[id="sc-9e4f7d84-3"]{content:"bVdaXF,"}/*!sc*/
.hufBEB{-webkit-flex:30;-ms-flex:30;flex:30;}/*!sc*/
.hufBEB img{width:100%;}/*!sc*/
data-styled.g100[id="sc-9e4f7d84-4"]{content:"hufBEB,"}/*!sc*/
</style></head><body><div id="__next"><div class="sc-b34fb00f-0 eWBvvS __className_87c83e"><nav class="sc-a026f25c-0 dAXQuQ"><div class="sc-61db3aea-0 eVggRJ"><div class="sc-a026f25c-1 gUFsBX"><a href="/"><img alt="Orange Logo" loading="lazy" width="120" height="35" decoding="async" data-nimg="1" class="img-logo" style="color:transparent" src="/_next/static/media/logo-orange.faff1861.svg"/></a><div><button aria-label="Toggle navigation" class="sc-46d6b9d9-0 eWdALT"><div></div><div></div><div></div></button><div class="sc-a026f25c-2 bcvGIl"><ul class="sc-a026f25c-3 jjIqRA"><li><a href="/screenshots/">Screenshots</a></li><li><a href="/download/">Download</a></li><li><a href="/blog/">Blog</a></li><li><a href="/docs/">Docs</a></li><li><a href="/workshops/">Workshops</a></li><li><a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&amp;hosted_button_id=A76TAX87ZVR3J">Donate</a></li></ul><form class="sc-a026f25c-4 eLPewT"><div class="sc-a026f25c-5 ipGgXV">Search</div><button class="sc-a026f25c-6 iFVURz"><img alt="Icon for search" loading="lazy" width="18" height="17" decoding="async" data-nimg="1" style="color:transparent" src="/_next/static/media/icon-search.459b2665.svg"/><span class="sc-cdea7863-0 jTcDmc">Search through page</span></button></form></div></div></div></div></nav><main><div class="sc-61db3aea-0 hRMVSr"><h1 class="sc-89e95305-0 sc-ba990baf-0 iNzSUu dXFGRw"> <!-- -->Examples</h1><div class="sc-889b783c-0 hvTfLC"><button class="sc-d3c41432-0 gTOGMU">Text Mining</button><button class="sc-d3c41432-0 gTOGMU">Bioinformatics</button><button class="sc-d3c41432-0 gTOGMU">Fairness</button><button class="sc-d3c41432-0 gTOGMU">Survival Analysis</button><button class="sc-d3c41432-0 gTOGMU">Classification</button><button class="sc-d3c41432-0 gTOGMU">Clustering</button><button class="sc-d3c41432-0 gTOGMU">Hierarchical Clustering</button><button class="sc-d3c41432-0 gTOGMU">Cox Regression</button><button class="sc-d3c41432-0 gTOGMU">Scatter Plot</button><button class="sc-d3c41432-0 gTOGMU">Visualization</button></div><ul class="sc-9e4f7d84-0 ENlF"><li class="sc-9e4f7d84-2 jLRiqb"><div class="sc-9e4f7d84-3 bVdaXF"><p class="sc-3c206b28-3 gRZIks"><span><span>Data Table</span>, </span><span><span>Data Loading</span></span></p><h2>File and Data Table</h2><div class="sc-9e4f7d84-1 gEwLqo"><p>The basic data mining units in Orange are called widgets. In this workflow, the File widget reads the data. File widget communicates this data to Data Table widget that shows the data in a spreadsheet. The output of File is connected to the input of Data Table.</p></div><a href="/examples/file-and-data-table-widget/110-file-and-data-table-widget.ows" class="sc-b6ea565a-0 jyxOJT">Download</a></div><div class="sc-9e4f7d84-4 hufBEB"><img alt="" loading="lazy" width="1380" height="840" decoding="async" data-nimg="1" style="color:transparent" src="/examples/file-and-data-table-widget/file-and-data-table-widget.png"/></div></li><li class="sc-9e4f7d84-2 jLRiqb"><div class="sc-9e4f7d84-3 bVdaXF"><p class="sc-3c206b28-3 gRZIks"><span><span>Scatter Plot</span>, </span><span><span>Visualization</span></span></p><h2>Interactive Visualizations</h2><div class="sc-9e4f7d84-1 gEwLqo"><p>Most visualizations in Orange are interactive. Scatter Plot for example. Double click its icon to open it and click-and-drag to select a few data points from the plot. Selected data will automatically propagate to Data Table. Double click it to check which data was selected. Change selection and observe the change in the Data Table. This works best if both widgets are open.</p></div><a href="/examples/scatterplot-data-table/120-scatterplot-data-table.ows" class="sc-b6ea565a-0 jyxOJT">Download</a></div><div class="sc-9e4f7d84-4 hufBEB"><img alt="" loading="lazy" width="1241" height="763" decoding="async" data-nimg="1" style="color:transparent" src="/examples/scatterplot-data-table/scatterplot-data-table.png"/></div></li><li class="sc-9e4f7d84-2 jLRiqb"><div class="sc-9e4f7d84-3 bVdaXF"><p class="sc-3c206b28-3 gRZIks"><span><span>Scatter Plot</span>, </span><span><span>Visualization</span></span></p><h2>Visalization of Data Subsets</h2><div class="sc-9e4f7d84-1 gEwLqo"><p>Some visualization widget, like Scatter Plot and several data projection widgets, can expose the data instances in the data subset. In this workflow, Scatter Plot visualizes the data from the input data file, but also marks the data points that have been selected in the Data Table (selected rows).</p></div><a href="/examples/data-subsets/130-scatterplot-visualize-subset.ows" class="sc-b6ea565a-0 jyxOJT">Download</a></div><div class="sc-9e4f7d84-4 hufBEB"><img alt="" loading="lazy" width="1316" height="801" decoding="async" data-nimg="1" style="color:transparent" src="/examples/data-subsets/scatterplot-visualize-subset.png"/></div></li><li class="sc-9e4f7d84-2 jLRiqb"><div class="sc-9e4f7d84-3 bVdaXF"><p class="sc-3c206b28-3 gRZIks"><span><span>Data</span>, </span><span><span>Pivot Table</span></span></p><h2>Pivot Table</h2><div class="sc-9e4f7d84-1 gEwLqo"><p>Pivot Table can help us aggregate and transform the data. This workflow takes Kickstarter projects and aggregates them by month. We can inspect the frequency of the published projects per month and observe the difference between funded and non-funded projects. Try constructing several tables with pivot and experiment with different aggregation methods.</p></div><a href="/examples/pivot-table/140-pivot-table.ows" class="sc-b6ea565a-0 jyxOJT">Download</a></div><div class="sc-9e4f7d84-4 hufBEB"><img alt="" loading="lazy" width="1592" height="969" decoding="async" data-nimg="1" style="color:transparent" src="/examples/pivot-table/pivot-table.png"/></div></li><li class="sc-9e4f7d84-2 jLRiqb"><div class="sc-9e4f7d84-3 bVdaXF"><p class="sc-3c206b28-3 gRZIks"><span><span>Classification Tree</span>, </span><span><span>Classification</span></span></p><h2>Classification Tree</h2><div class="sc-9e4f7d84-1 gEwLqo"><p>This workflow combines the interface and visualization of classification trees with scatter plot. When both the tree viewer and the scatter plot are open, selection of any node of the tree sends the related data instances to scatter plot. In the workflow, the selected data is treated as a subset of the entire dataset and is highlighted in the scatter plot. With simple combination of widgets we have constructed an interactive classification tree browser.</p></div><a href="/examples/tree-scatterplot/250-tree-scatterplot.ows" class="sc-b6ea565a-0 jyxOJT">Download</a></div><div class="sc-9e4f7d84-4 hufBEB"><img alt="" loading="lazy" width="1437" height="875" decoding="async" data-nimg="1" style="color:transparent" src="/examples/tree-scatterplot/tree-scatterplot.png"/></div></li></ul><div class="sc-a2f31186-0 bdlyrE"><button class="sc-a2f31186-1 jQYhVi">1</button><button class="sc-a2f31186-1 ewzjsY">2</button><button class="sc-a2f31186-1 ewzjsY">3</button><span>...</span><button class="sc-a2f31186-1 ewzjsY">9</button><button aria-label="next page" class="sc-a2f31186-2 fQlHUc"><span>Next</span><img alt="" loading="lazy" width="7" height="10" decoding="async" data-nimg="1" style="color:transparent" src="/_next/static/media/icon-arrow.a5093233.svg"/></button></div></div></main><footer class="sc-3419d6b6-0 ioIxRn"><div class="sc-61db3aea-0 eVggRJ"><div class="sc-3419d6b6-1 iYFXoP"><div><h3>Orange</h3><ul><li><a href="/faq/">FAQ</a></li><li><a href="/license/">License</a></li><li><a href="/privacy/">Privacy</a></li><li><a href="/citation/">Citation</a></li><li><a href="/contact/">Contact</a></li></ul></div><div><h3><a href="/download/">Download</a></h3><ul><li><a href="/download/#win">Windows</a></li><li><a href="/download/#mac">Mac OS</a></li><li><a href="/download/#other">Other platforms</a></li></ul></div><div><h3>Community</h3><ul><li><a href="https://twitter.com/OrangeDataMiner">Twitter</a></li><li><a href="https://www.facebook.com/orangedatamining">Facebook</a></li><li><a href="https://datascience.stackexchange.com/questions/tagged/orange">Stack Exchange</a></li><li><a href="https://www.youtube.com/channel/UClKKWBe2SCAEyv7ZNGhIe4g">YouTube</a></li><li><a href="https://discord.com/invite/FWrfeXV">Discord</a></li></ul></div><div><h3><a href="/docs/">Documentation</a></h3><ul><li><a href="/getting-started/">Get started</a></li><li><a href="https://www.youtube.com/channel/UClKKWBe2SCAEyv7ZNGhIe4g">YouTube tutorials</a></li><li><a href="/examples/">Example workflows</a></li><li><a href="/widget-catalog/">Widgets</a></li><li><a href="https://orange3.readthedocs.io/projects/orange-data-mining-library/en/latest/">Scripting</a></li></ul></div><div><h3>Developers</h3><ul><li><a href="https://github.com/biolab/orange3">GitHub</a></li><li><a href="http://docs.biolab.si/3/development/">Getting started</a></li></ul></div><div><a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&amp;hosted_button_id=A76TAX87ZVR3J" target="_blank" rel="noreferrer" class="sc-b6ea565a-0 jyxOJT">Donate to Orange</a></div></div><p>Copyright Â© University of Ljubljana</p></div></footer><div class="sc-7e1621ad-1 kkwPib"><div><p>This site uses cookies to improve your experience.</p><div class="sc-7e1621ad-0 kOMJoa"><button class="sc-7e1621ad-2 fkWelF">Details</button><button class="sc-7e1621ad-2 dsztgy">Understand</button></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"examples":[{"title":"File and Data Table","images":[{"width":1380,"height":840,"src":"/examples/file-and-data-table-widget/file-and-data-table-widget.png"}],"type":"workflows","blog_link":"","video":"","download":"/examples/file-and-data-table-widget/110-file-and-data-table-widget.ows","workflows":["Data Table","Data Loading"],"weight":120,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"The basic data mining units in Orange are called widgets. In this workflow, the File widget reads the data. File widget communicates this data to Data Table widget that shows the data in a spreadsheet. The output of File is connected to the input of Data Table.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Interactive Visualizations","images":[{"width":1241,"height":763,"src":"/examples/scatterplot-data-table/scatterplot-data-table.png"}],"type":"workflows","blog_link":"","video":"","download":"/examples/scatterplot-data-table/120-scatterplot-data-table.ows","workflows":["Scatter Plot","Visualization"],"weight":120,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"Most visualizations in Orange are interactive. Scatter Plot for example. Double click its icon to open it and click-and-drag to select a few data points from the plot. Selected data will automatically propagate to Data Table. Double click it to check which data was selected. Change selection and observe the change in the Data Table. This works best if both widgets are open.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Visalization of Data Subsets","images":[{"width":1316,"height":801,"src":"/examples/data-subsets/scatterplot-visualize-subset.png"}],"type":"workflows","blog_link":"","video":"","download":"/examples/data-subsets/130-scatterplot-visualize-subset.ows","workflows":["Scatter Plot","Visualization"],"weight":130,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"Some visualization widget, like Scatter Plot and several data projection widgets, can expose the data instances in the data subset. In this workflow, Scatter Plot visualizes the data from the input data file, but also marks the data points that have been selected in the Data Table (selected rows).\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Pivot Table","images":[{"width":1592,"height":969,"src":"/examples/pivot-table/pivot-table.png"}],"type":"workflows","blog_link":"","video":"","download":"/examples/pivot-table/140-pivot-table.ows","workflows":["Data","Pivot Table"],"weight":140,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"Pivot Table can help us aggregate and transform the data. This workflow takes Kickstarter projects and aggregates them by month. We can inspect the frequency of the published projects per month and observe the difference between funded and non-funded projects. Try constructing several tables with pivot and experiment with different aggregation methods.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Classification Tree","images":[{"width":1437,"height":875,"src":"/examples/tree-scatterplot/tree-scatterplot.png"}],"type":"workflows","blog_link":"","video":"","download":"/examples/tree-scatterplot/250-tree-scatterplot.ows","workflows":["Classification Tree","Classification"],"weight":250,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"This workflow combines the interface and visualization of classification trees with scatter plot. When both the tree viewer and the scatter plot are open, selection of any node of the tree sends the related data instances to scatter plot. In the workflow, the selected data is treated as a subset of the entire dataset and is highlighted in the scatter plot. With simple combination of widgets we have constructed an interactive classification tree browser.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Inspecting Outliers with Silhouette","images":[{"width":1329,"height":809,"src":"/examples/outliers/silhouette.png"}],"type":"workflows","blog_link":"","video":"","download":"/examples/outliers/260-outliers.ows","workflows":["Silhouette","Outliers","Visualization"],"weight":260,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"Silhouette Plot shows how 'well-centered' each data instance is with respect to its cluster or class label. In this workflow we use iris' class labels to observe which flowers are typical representatives of their class and which are the outliers. Select instances left of zero in the plot and observe which flowers are these. Try connecting the selection with the Scatter Plot to highlight the outliers.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Principal Component Analysis","images":[{"width":1167,"height":711,"src":"/examples/principal-component-analysis/pca.png"}],"type":"workflows","blog_link":"","video":"","download":"/examples/principal-component-analysis/305-pca.ows","workflows":["PCA","Dimensionality Reduction"],"weight":305,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"PCA transforms the data into a dataset with uncorrelated variables, also called principal components. PCA widget displays a graph (scree diagram) showing a degree of explained variance by best principal components and allows to interactively set the number of components to be included in the output dataset. In this workflow, we can observe the transformation in the Data Table and in Scatter Plot.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Hierarchical Clustering","images":[{"width":1610,"height":980,"src":"/examples/hierarchical-clustering/hierarchical-clustering.png"}],"type":"workflows","blog_link":"","video":"","download":"/examples/hierarchical-clustering/310-clustering.ows","workflows":["Hierarchical Clustering","Clustering"],"weight":310,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"The workflow clusters the data items in iris dataset by first examining the distances between data instances. Distance matrix is passed to Hierarchical Clustering, which renders the dendrogram. Select different parts of the dendrogram to further analyze the corresponding data.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Cluster Inspection","images":[{"width":1380,"height":840,"src":"/examples/cluster-inspection/cluster-inspection.png"}],"type":"workflows","blog_link":"","video":"","download":"/examples/cluster-inspection/315-cluster-inspection.ows","workflows":["Clustering","Hierarchical Clustering","Box Plot"],"weight":315,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"We use the zoo data set in combination with Hierarchical Clustering to discover groups of animals. Now that we have the clusters we want to find out what is significant for each cluster! Pass the clusters to Box Plot and use 'Order by relevance' to discover what defines a cluster. Seems like they are well-separated by the type, even though the clustering was unaware of the class label!\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Feature Ranking","images":[{"width":1196,"height":728,"src":"/examples/feature-ranking/feature-ranking.png"}],"type":"workflows","blog_link":"","video":"","download":"/examples/feature-ranking/410-feature-ranking.ows","workflows":["Feature Ranking","Feature Selection"],"weight":410,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"For supervised problems, where data instances are annotated with class labels, we would like to know which are the most informative features. Rank widget provides a table of features and their informativity scores, and supports manual feature selection. In the workflow, we used it to find the best two features (of initial 79 from brown-selected dataset) and display its scatter plot.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Train and Test Data","images":[{"width":1637,"height":997,"src":"/examples/data-sampler/data-sampler.png"}],"type":"workflows","blog_link":"","video":"","download":"/examples/data-sampler/420-data-sampler.ows","workflows":["Classification","Data Sampler","Predictive models"],"weight":420,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"In building predictive models it is important to have a separate train and test data sets in order to avoid overfitting and to properly score the models. Here we use Data Sampler to split the data into training and test data, use training data for building a model and, finally, test on test data. Try several other classifiers to see how the scores change.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Cross Validation","images":[{"width":1135,"height":691,"src":"/examples/cross-validation/cross-validation.png"}],"type":"workflows","blog_link":"","video":"","download":"/examples/cross-validation/450-cross-validation.ows","workflows":["Cross Validation","Predictive models","Classification"],"weight":450,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"How good are supervised data mining methods on your classification dataset? Here's a workflow that scores various classification techniques on a dataset from medicine. The central widget here is the one for testing and scoring, which is given the data and a set of learners, does cross-validation and scores predictive accuracy, and outputs the scores for further examination.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Where Are Misclassifications","images":[{"width":1079,"height":657,"src":"/examples/where-are-misclassifications/misclassifications.png"}],"type":"workflows","blog_link":"","video":"","download":"/examples/where-are-misclassifications/470-misclassification-scatterplot.ows","workflows":["Confusion Matrix","Classification","Scatter Plot"],"weight":470,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"Cross-validation of, say, logistic regression can expose the data instances which were misclassified. There are six such instances for iris dataset and ridge-regularized logistic regression. We can select different types of misclassification in Confusion Matrix and highlight them in the Scatter Plot. No surprise: the misclassified instances are close to the class-bordering regions in the scatter plot projection.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Text Preprocessing","images":[{"width":1271,"height":774,"src":"/examples/text-preprocessing/text-preprocessing.png"}],"type":"workflows","blog_link":"/blog/2017/06/19/text-preprocessing/","video":"https://youtu.be/V70UwJZWkZ8","download":"/examples/text-preprocessing/610-text-preprocessing.ows","workflows":["Text Mining","Preprocessing","Tokenization"],"weight":610,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"Text mining requires careful preprocessing. Here's a workflow that uses simple preprocessing for creating tokens from documents. First, it applies lowercase, then splits text into words, and finally, it removes frequent stopwords. Preprocessing is language specific, so change the language to the language of texts where required. Results of preprocessing can be observe in a Word Cloud.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Text Clustering","images":[{"width":1518,"height":924,"src":"/examples/text-clustering/text-clustering.png"}],"type":"workflows","blog_link":"","video":"https://youtu.be/rH_vQxQL6oM","download":"/examples/text-clustering/620-text-clustering.ows","workflows":["Text Mining","Clustering","Tokenization"],"weight":620,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"The workflow clusters Grimm's tales corpus. We start by preprocessing the data and constructing the bag of words matrix. Then we compute cosine distances between documents and use Hierarchical Clustering, which displays the dendrogram. We observe how well the type of the tale corresponds to the cluster in the MDS.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Text Classification","images":[{"width":1748,"height":1064,"src":"/examples/text-classification/text-classification.png"}],"type":"workflows","blog_link":"","video":"https://youtu.be/zO_zwKZCULo","download":"/examples/text-classification/630-text-classification.ows","workflows":["Text Mining","Classification","Nomogram","Bag of Words"],"weight":630,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"We can use predictive models to classify documents by authorship, their type, sentiment and so on. In this workflow we classify documents by their Aarne-Thompshon-Uther index, that is the defining topic of the tale. We use two simple learners, Logistic Regression and Naive Bayes, both of which can be inspected in the Nomogram.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Twitter Data Analysis","images":[{"width":1326,"height":807,"src":"/examples/twitter/twitter.png"}],"type":"workflows","blog_link":"","video":"https://youtu.be/HDkI6G4slzQ","download":"/examples/twitter/640-twitter.ows","workflows":["Text Mining","Twitter","Topic Modeling"],"weight":640,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"Tweets are a valuable source of information, for social scientists, marketing managers, linguists, economists, and so on. In this workflow we retrieve data from Twitter, preprocess it, and uncover latent topics with topic modeling. We observe the topics in a Heat Map.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Story Arcs","images":[{"width":1278,"height":778,"src":"/examples/story-arcs/story-arcs.png"}],"type":"workflows","blog_link":"/blog/2020/2020-07-27-story-arcs/","video":"","download":"/examples/story-arcs/650-story-arcs.ows","workflows":["Text Mining","Timeseries","Sentiment Analysis"],"weight":649,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"In this workflow we explore story arcs in the Little Match Seller story. First we select the story from the corpus of Andersen tales. Then we create a table, where each sentence of the tale is a separate row. We use sentiment analysis to compute the sentiment of each sentence, then observe the emotional arcs through the story. We also inspect sentences with similar scores in the Heat Map and Corpus Viewer.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Load Text Corpus from the Server Repository","images":[{"width":553,"height":319,"src":"/examples/text-loading-from-repository/text-loading-from-repository.png"}],"type":"workflows","blog_link":"","video":"","download":"/examples/text-loading-from-repository/text-loading-from-repository.ows","workflows":["Text Mining"],"weight":650,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_components.p, {\n    children: [\"The workflow loads the corpus from the \", _jsx(_components.a, {\n      href: \"http://file.biolab.si/text-semantics/data/predlogi-vladi-1k/\",\n      children: \"text repository on the server\"\n    }), \". The repository contains documents with raw text and associated YAML files with meta-features. We here use some pre-processing and then display the most frequent words in a word cloud. This workflow could work on your repository: just change the URL in the Import Documents widget.\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Semantic Document Map","images":[{"width":671,"height":329,"src":"/examples/text-semantic-document-map/text-semantic-document-map.png"}],"type":"workflows","blog_link":"","video":"","download":"/examples/text-semantic-document-map/text-semantic-document-map.ows","workflows":["Text Mining"],"weight":652,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"Document maps may reveal clusters of documents with semantically similar content. Here we show a workflow that loads the corpus, performs some text preprocessing and embeds the documents in the vector space using the fastText deep model. The t-SNE widget reveals the document map, where we can select a set of documents and then explore them in Corpus Viewer or characterize them in the display of the most frequent words in the Word Cloud.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Semantic Word Map","images":[{"width":701,"height":395,"src":"/examples/text-semantic-word-map/text-semantic-word-map.png"},{"width":758,"height":581,"src":"/examples/text-semantic-word-map/text-semantic-word-map-tsne.png"}],"type":"workflows","blog_link":"","video":"","download":"/examples/text-semantic-word-map/text-semantic-word-map.ows","workflows":["Text Mining"],"weight":654,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"We can find clusters of semantically related words either by hierarchical clustering or t-SNE visualizations. Here, we show a workflow that loads the documents, extracts frequent words, embeds them in a vector space, and explores word clusters.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Semantic search","images":[{"width":956,"height":718,"src":"/examples/text-semantic-viewer/text-semantic-search.png"},{"width":985,"height":560,"src":"/examples/text-semantic-viewer/text-semantic-search-widget.png"}],"type":"workflows","blog_link":"","video":"","download":"/examples/text-semantic-viewer/text-semantic-search.ows","workflows":["Text Mining"],"weight":655,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"We can find relevant parts of a document by searching for exact words or parts of documents with similar meanings. The Semantic Viewer widget in this workflow searches for pertinent sentences of the documents by comparing the meaning of words from the Word List widget to the meaning of sentences in the text via SBERT text embeddings. The widget ranks documents by scores measuring their relevance, shows selected documents, and highlights the relevant parts.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Keyword Extraction from a Set of Text Documents","images":[{"width":587,"height":336,"src":"/examples/text-keyword-extraction/text-keyword-extraction.png"}],"type":"workflows","blog_link":"","video":"","download":"/examples/text-keyword-extraction/text-keyword-extraction.ows","workflows":["Text Mining"],"weight":656,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"The Extract Keywords widget can characterize a set of textual documents. In this workflow, we load the documents from the server, preprocess them and embed them in the vector space, and display a semantic document map in the t-SNE widget. In this widget, we can select a set of similar documents and then characterize them through keyword extraction. Extract keywords support different inference techniques, including TF-IDF and deep network-based characterization.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Keyword-Based Text Document Scoring","images":[{"width":796,"height":392,"src":"/examples/text-keyword-based-scoring/text-keyword-based-scoring.png"}],"type":"workflows","blog_link":"","video":"","download":"/examples/text-keyword-based-scoring/text-keyword-based-scoring.ows","workflows":["Text Mining"],"weight":658,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"We can score the text documents based on a list of keywords, say, to find the documents which include the keywords or are semantically related to the list of keywords. This workflow shows the Score Documents widget for scoring and the Word List widget to compose a list of keywords. The scores are visualized in the t-SNE document map.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Corpus and Word Maps","images":[{"width":2226,"height":892,"src":"/examples/text-corpus-and-word-map/text-corpus-and-word-map.png"}],"type":"workflows","blog_link":"","video":"","download":"/examples/text-corpus-and-word-map/text-corpus-and-word-map.ows","workflows":["Text Mining"],"weight":660,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"This workflow shows how to extract the most common words from the documents and observe clusters of semantically similar words with Hierarchical Clustering. We select a group of words (connected to the traffic and roads) and use them to score documents according to selection with the Score Documents widget. The scores are visualized in the document map by the Self-Organizing Maps widget.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Document Map Annotation","images":[{"width":1606,"height":590,"src":"/examples/text-annotator/text-annotator.png"}],"type":"workflows","blog_link":"","video":"","download":"/examples/text-annotator/text-annotator.ows","workflows":["Text Mining"],"weight":664,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"Documents maps can be enhanced with the keywords annotations. This workflow embeds documents in vector space, computes a t-SNE document map and annotates it. The Annotator widget identifies clusters on the map and annotates them with keywords representing a cluster.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Ontology Generation from Keywords","images":[{"width":1438,"height":534,"src":"/examples/text-ontology/text-ontology.png"}],"type":"workflows","blog_link":"","video":"","download":"/examples/text-ontology/text-ontology.ows","workflows":["Text Mining"],"weight":668,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"We can automatically build the otology from the set of words. In the workflow, we select a group of documents with similar content. From the selected documents, we extract keywords and generate a new ontology from the subset of keywords with the Ontology widget.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Survival Curve Estimation","images":[{"width":581,"height":310,"src":"/examples/survival-curve-estimation/700_survival_curve_estimation.png"}],"type":"workflows","blog":"","video":"","download":"/examples/survival-curve-estimation/700_survival_curve_estimation.ows","workflows":["Survival Analysis"],"weight":700,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"One of the primary objectives of survival analysis is to estimate the survival probability from observed survival times of different patients. The workflow plots the Kaplan-Meier approximation of the survival curve for the investigated population in the German breast cancer study group. The Kaplan-Meier plot is interactive; we select the longest-surviving patients and use Box Plot to analyze features that best characterize them.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Exploring Survival Features","images":[{"width":621,"height":343,"src":"/examples/exploring-survival-features/710_survival_features.png"}],"type":"workflows","blog":"","video":"","download":"/examples/exploring-survival-features/710_survival_features.ows","workflows":["Survival Analysis","Cox Regression"],"weight":710,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"In the workflow, we show how to find and analyze variables related to survival. We start with variables ranked by univariate Cox regression analysis, where we can select the feature of interest. The Distribution widget shows its distribution and allows us to choose interactively a group of patients related to its values. We compare the survival of this group to all other patients in the Kaplan-Meier plot widget.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Cohort Construction and Validation","images":[{"width":1796,"height":686,"src":"/examples/cohort-construction-and-validation/720_cohort_construction_and_validation.png"}],"type":"workflows","blog":"","video":"","download":"/examples/cohort-construction-and-validation/720_cohort_construction_and_validation.ows","workflows":["Survival Analysis","Kaplan-Meier","Cox Regression"],"weight":720,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_components.p, {\n    children: [\"Stratification of patients into low and high-risk groups is a common task in survival analysis to identify clinical and biological factors that contribute to survival. One approach to stratification is by computing risk score values based on the Cox regression model. With the clever use of Orange widgets, we can split the data into training and validation sets and then interactively generate risk score models on training data to observe the difference in cohorts' survival rate on training and validation samples side-by-side. Read more on how \", _jsx(_components.a, {\n      href: \"blog/why-you-should-use-apply-domain\",\n      children: \"Apply domain\"\n    }), \" enables this kind of workflows.\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Cross Validation for Survival Models","images":[{"width":487,"height":343,"src":"/examples/c-index-cross-validation/730_c_index_cross_validation.png"}],"type":"workflows","blog":"","video":"","download":"/examples/c-index-cross-validation/730_c_index_cross_validation.ows","workflows":["Survival Analysis","Cox Regression","Concordance Index","Cross Validation"],"weight":730,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"Orange built-in methods for testing and scoring the predictive models now support survival-related models like Cox regression. Here we demonstrate cross-validation to estimate the concordance index for the Cox regression model trained on data instances from selected features.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Explore Subpopulations with Distinct Risk Profiles","images":[{"width":647,"height":419,"src":"/examples/explore-subpopulations-with-distinct-risk-profiles/740_hierarhical_clustering.png"}],"type":"workflows","blog":"","video":"","download":"/examples/explore-subpopulations-with-distinct-risk-profiles/740_hierarhical_clustering.ows","workflows":["Survival Analysis","Clustering","Hierarchical Clustering","Box Plot"],"weight":740,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"We can visualize the difference in subpopulations of breast cancer patients in the METABRIC dataset through clustering, that is, by identifying groups of data instances similar to each other. We can observe the difference in survival rate between clusters with Kaplan-Meier Plot and explore features that characterize patients of each cluster with the Box Plot widget.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Identify Differentially Expressed Genes with Volcano Plot","images":[{"width":902,"height":414,"src":"/examples/bioinformatics-volcano-plot/bioinformatics_volcano_plot.png"}],"type":"workflows","blog":"","video":"","download":"/examples/bioinformatics-volcano-plot/bioinformatics_volcano_plot.ows","workflows":["Bioinformatics"],"weight":800,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"Explore gene expression differences with a Volcano Plot in genomic analysis. Visualize significant upregulation or downregulation of genes between two conditions and identify critical genes with substantial changes and high statistical significance, potentially revealing key biomarkers or therapeutic targets.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Find Homologs for Differentially Expressed Genes","images":[{"width":982,"height":401,"src":"/examples/bioinformatics-homologs/bioinformatics_homologs.png"}],"type":"workflows","blog":"","video":"","download":"/examples/bioinformatics-homologs/bioinformatics_homologs.ows","workflows":["Bioinformatics"],"weight":810,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"Homologous genes, although not identical, often perform analogous functions in different organisms. Here, we show a workflow that loads a mouse gene expression dataset, annotates the genes, select the top 100 differentially expressed genes, and finds their human homologs.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Score Overexpressed Genes in Individual Samples","images":[{"width":1190,"height":443,"src":"/examples/bioinformatics-gene-sets/bioinformatics_gene_sets.png"}],"type":"workflows","blog":"","video":"","download":"/examples/bioinformatics-gene-sets/bioinformatics_gene_sets.ows","workflows":["Bioinformatics"],"weight":820,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"Studying specific genes linked to a biological process or disease can yield valuable insights. We present a workflow to analyze the expression of 284 human homologs of E.coli DNA damage-up proteins (DDPs). These DDPs fall into three gene sets: All DDPs, excluding known cancer drivers, and validated DDPs causing DNA damage in human cells. Enrichment scores are assigned using the Single Sample Scoring widget.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Cluster gene expression and enrichment","images":[{"width":1026,"height":443,"src":"/examples/bioinformatics-cluster-analysis/bioinformatics_cluster_analysis.png"}],"type":"workflows","blog":"","video":"","download":"/examples/bioinformatics-cluster-analysis/bioinformatics_cluster_analysis.ows","workflows":["Bioinformatics"],"weight":830,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"Analyzing the differential expression of genes characterizing clusters and enriched gene sets helps uncover specific molecular pathways and regulatory mechanisms that contribute to distinct biological functions or disease states. In this workflow, we use the Cluster Analysis to identify differentially expressed genes and the enriched gene sets that define the clusters.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Mental health of tech employees in times of COVID-19","images":[{"width":1372,"height":850,"src":"/examples/mental-health/mental-health.png"}],"type":"workflows","blog_link":"https://ocean.sagepub.com/blog/mental-health-of-tech-employees-in-times-of-covid-19","video":"","download":"/examples/mental-health/900_mental-health.ows","workflows":["mental health","survey","Hierarchical Clustering"],"weight":900,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_components.p, {\n    children: [\"The COVID-19 pandemic brought about many societal changes, including a serious effect on mental health. The Open Sourcing Mental Health 2021 survey measures attitudes towards mental health in the tech workplace and examines the frequency of mental health disorders among tech workers. The workflow presents how to uncover different types of tech employees based on their responses. The procedure is fully described in the \", _jsx(_components.a, {\n      href: \"https://ocean.sagepub.com/blog/mental-health-of-tech-employees-in-times-of-covid-19\",\n      children: \"SAGE Ocean blog\"\n    }), \".\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Annotate Cells Using Marker Genes","images":[{"width":894,"height":569,"src":"/examples/bioinformatics-annotator/bioinformatics_annotator.png"}],"type":"workflows","blog":"","video":"","download":"/examples/bioinformatics-annotator/bioinformatics_annotator.ows","workflows":["Bioinformatics"],"weight":940,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"Annotating cells with marker genes identifies cell types, enhancing the understanding of functions and interactions in studies such as single-cell analysis. This workflow involves loading a single-cell dataset, identifying marker genes, and annotating cells based on gene expression, utilizing the t-SNE widget for visualization.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Gene Set Enrichment Analysis","images":[{"width":666,"height":374,"src":"/examples/bioinformatics-gsea/bioinformatics_gsea.png"}],"type":"workflows","blog":"","video":"","download":"/examples/bioinformatics-gsea/bioinformatics_gsea.ows","workflows":["Bioinformatics"],"weight":950,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"Find gene sets overrepresented in a large group of genes, possibly associated with different phenotypes. Gene Set Enrichment Analysis widget provides a list of gene sets and their enrichment scores, and supports manual selection of gene sets.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Dataset Bias Examination","images":[{"width":963,"height":440,"src":"/examples/fairness-dataset-bias/fairness-dataset-bias.png"}],"type":"workflows","blog_link":"/blog/2023/2023-09-18-fairness-dataset-bias/","video":"","download":"/examples/fairness-dataset-bias/fairness-dataset-bias.ows","workflows":["Fairness"],"weight":1000,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"Understanding the potential biases within datasets is crucial for fair machine-learning outcomes. This workflow detects dataset bias using a straightforward algorithm. After loading the dataset, we add specific fairness attributes to it, which are essential for our calculations. We then compute the fairness metrics via the Dataset Bias widget and explain the results in a Box Plot.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Reweighing a Dataset","images":[{"width":1320,"height":540,"src":"/examples/fairness-reweighing-dataset/fairness-reweighing-dataset.png"}],"type":"workflows","blog_link":"/blog/2023/2023-09-19-fairness-reweighing-dataset/","video":"","download":"/examples/fairness-reweighing-dataset/fairness-reweighing-dataset.ows","workflows":["Fairness"],"weight":1001,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"Detecting bias is only the first step in ensuring fair machine learning. The next step is to mitigate the bias. This workflow illustrates removing bias at the dataset level using the Reweighing widget. Initially, split the data into training and validation subsets. We then check for bias in the validation set before reweighing. Using the training set, we train the reweighing algorithm and apply it to the validation set. Finally, we check for bias in the reweighed validation set. We can also visualize the effect of the reweighing using a Box Plot.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Reweighing as a preprocessor","images":[{"width":1367,"height":645,"src":"/examples/fairness-reweighing-preprocessor/fairness-reweighing-preprocessor.png"}],"type":"workflows","blog_link":"/blog/2023/2023-09-19-fairness-reweighing-preprocessor/","video":"","download":"/examples/fairness-reweighing-preprocessor/fairness-reweighing-preprocessor.ows","workflows":["Fairness"],"weight":1002,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"We can use the reweighing fairness algorithm for more than just adding weights to a dataset. It can also be used as a preprocessor for a specific model. This workflow illustrates how to use the Reweighing widget as a preprocessor for the Logistic Regression model. Initially, we load the dataset and input it into the Test and Score widget, which we will use to evaluate our model. Now, we need to connect a Logistic Regression model, which has the Reweighing widget as a preprocessor, to the Test and Score widget. Doing so ensures our data gets reweighed before the model learns from it. We compare these results against those derived from a Logistic Regression model without reweighing and visualize both using a Box Plot.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Adversarial Debiasing","images":[{"width":926,"height":517,"src":"/examples/fairness-adversarial-debiasing/fairness-adversarial-debiasing.png"}],"type":"workflows","blog_link":"/blog/2023/2023-09-19-fairness-adversarial-debiasing/","video":"","download":"/examples/fairness-adversarial-debiasing/fairness-adversarial-debiasing.ows","workflows":["Fairness"],"weight":1003,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"The easiest method to address bias in machine learning is to use a bias-aware model. This approach eliminates the need for fairness preprocessing or postprocessing. In this workflow, we will employ a bias-aware model named Adversarial Debasing for classification. We will train two versions of this model: one with and one without debiasing. Finally, we will compare and display the fairness metrics using a box plot widget.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Equal Odds Postprocessing","images":[{"width":1198,"height":620,"src":"/examples/fairness-equal-odds-postprocessing/fairness-equal-odds-postprocessing.png"}],"type":"workflows","blog_link":"/blog/2023/2023-09-19-fairness-equal-odds-postprocessing/","video":"","download":"/examples/fairness-equal-odds-postprocessing/fairness-equal-odds-postprocessing.ows","workflows":["Fairness"],"weight":1004,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"Another way to mitigate bias is to use a postprocessing algorithm on the model's predictions. This workflow illustrates using the Equal Odds widget as a post-processor for the Logistic Regression model. To use the post-processor, we need to connect any model to the Equalized Odds Postprocessing widget along with any needed pre-processors. Doing so ensures our model's predictions get post-processed before we evaluate them.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Hiding Protected Attribute","images":[{"width":1212,"height":717,"src":"/examples/fairness-hiding-protected-attribute/fairness-hiding-protected-attribute.png"}],"type":"workflows","blog_link":"/blog/2023/2023-09-19-fairness-hiding-protected-attribute/","video":"","download":"/examples/fairness-hiding-protected-attribute/fairness-hiding-protected-attribute.ows","workflows":["Fairness"],"weight":1005,"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsx(_components.p, {\n    children: \"Why would we use fairness algorithms instead of simply removing the protected attribute to avoid bias? This workflow illustrates why that is not such a good idea. We compare the predictions of a model using Reweighing to those of a model on data with the protected attribute removed. We use Box Plot to visualize and compare common fairness metrics.\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}}],"tags":["Text Mining","Bioinformatics","Fairness","Survival Analysis","Classification","Clustering","Hierarchical Clustering","Cox Regression","Scatter Plot","Visualization"]},"__N_SSG":true},"page":"/examples","query":{},"buildId":"ZuZfkfEcjaJ1Uvd7EKiHp","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>