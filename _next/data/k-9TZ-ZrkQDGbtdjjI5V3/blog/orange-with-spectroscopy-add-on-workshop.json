{"pageProps":{"frontmatter":{"author":"AJDA","date":"2018-03-28 10:36:18+00:00","draft":false,"title":"Orange with Spectroscopy Add-on Workshop","type":"blog","blog":["addons","education","examples","infrared spectra","workshop"]},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    img: \"img\",\n    em: \"em\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"We have just concluded our enhanced Introduction to Data Science workshop, which included several workflows for spectroscopy analysis. \", _jsx(_components.a, {\n        href: \"https://www.tandfonline.com/doi/full/10.1080/08940886.2017.1338424?src=recsys\",\n        children: \"Spectroscopy add-on\"\n      }), \" is intended for the analysis of spectral data and it is just as fun as our other add-ons (if not more!).\"]\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/blog/2018-03-orange-with-spectroscopy-add-on-workshop/delavnica-spectroscopy.jpg\",\n      alt: \"\",\n      width: \"1600\",\n      height: \"674\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We will prove it with a simple classification workflow. First, install Spectroscopy add-on from Options - Add-ons menu in Orange. Restart Orange for the add-on to appear. Great, you are ready for some spectral analysis!\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Use Datasets widget and load \", _jsx(_components.em, {\n        children: \"Collagen spectroscopy\"\n      }), \" data. This data contains cells measured with \", _jsx(_components.a, {\n        href: \"https://en.wikipedia.org/wiki/Fourier-transform_infrared_spectroscopy\",\n        children: \"FTIR\"\n      }), \" and annotated with the major chemical compound at the imaged part of a cell. A quick glance in a Data Table will give us an idea how the data looks like. Seems like a very standard spectral data set.\"]\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/blog/2018-03-orange-with-spectroscopy-add-on-workshop/Screen-Shot-2018-03-28-at-09.54.14.png\",\n      alt: \"\",\n      width: \"1600\",\n      height: \"763\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Collagen data set from Datasets widget.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now we want to determine, whether we can classify cells by type based on their spectral profiles. First, connect Datasets to Test & Score. We will use 10-fold cross-validation to score the performance of our model. Next, we will add Logistic Regression to model the data. One final thing. Spectral data often needs some preprocessing. Let us perform a simple preprocessing step by applying Cut (keep) filter and retaining only the wave numbers between 1500 and 1800. When we connect it to Test & Score, we need to keep in mind to connect the Preprocessor output of Preprocess Spectra.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.img, {\n        src: \"/blog/2018-03-orange-with-spectroscopy-add-on-workshop/Screen-Shot-2018-03-28-at-09.47.28.png\",\n        alt: \"\",\n        width: \"1528\",\n        height: \"1206\"\n      }), \"\\nPreprocessor that keeps a part of the spectra cut between 1500 and 1800. No data is shown here, since we are using only the preprocessing procedure as the input for Test & Score.\"]\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/blog/2018-03-orange-with-spectroscopy-add-on-workshop/Screen-Shot-2018-03-28-at-09.47.06.png\",\n      alt: \"\",\n      width: \"1478\",\n      height: \"448\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Let us see how well our model performs. Not bad. A 0.99 AUC score. Seems like it is almost perfect. But is it really so?\"\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/blog/2018-03-orange-with-spectroscopy-add-on-workshop/Screen-Shot-2018-03-28-at-09.47.39.png\",\n      alt: \"\",\n      width: \"1412\",\n      height: \"870\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"10-fold cross-validation on spectral data. Our AUC and CA scores are quite impressive.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Confusion Matrix gives us a detailed picture. Our model fails almost exclusively on DNA cell type. Interesting.\"\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/blog/2018-03-orange-with-spectroscopy-add-on-workshop/Screen-Shot-2018-03-28-at-09.47.44.png\",\n      alt: \"\",\n      width: \"1500\",\n      height: \"724\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Confusion Matrix shows DNA is most often misclassified. By selecting the misclassified instances in the matrix, we can inspect why Logistic Regression couldn't model these spectra\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We will select the misclassified DNA cells and feed them to Spectra to inspect what went wrong. Instead of coloring by type, we will color by prediction from Logistic Regression. Can you find out why these spectra were classified incorrectly?\"\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/blog/2018-03-orange-with-spectroscopy-add-on-workshop/Screen-Shot-2018-03-28-at-09.47.52.png\",\n      alt: \"\",\n      width: \"1600\",\n      height: \"932\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Misclassified DNA spectra colored by the prediction made by Logistic Regression.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This is one of the simplest examples with spectral data. It is basically the same procedure as with standard data - data is fed as data, learner (LR) as learner and preprocessor as preprocessor directly to Test & Score to avoid overfitting. Play around with Spectroscopy add-on and let us know what you think! :)\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}