{"pageProps":{"frontmatter":{"author":"AJDA","date":"2017-02-23 10:11:16+00:00","draft":false,"title":"My First Orange Widget","type":"blog","blog":["examples","orange3","programming","widget"]},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    pre: \"pre\",\n    code: \"code\",\n    img: \"img\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"Recently, I took on a daunting task - programming my first widget. I'm not a programmer or a computer science grad, but I've been looking at Orange code for almost two years now and I thought I could handle it.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"I set to create a simple \", _jsx(_components.a, {\n        href: \"https://www.nottingham.ac.uk/alzsh3/acvocab/concordances.htm\",\n        children: \"Concordance\"\n      }), \" widget that displays word contexts in a corpus (the widget will be available in the future release). The widget turned out to be a little more complicated than I originally anticipated, but it was a great exercise in programming.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Today, I'll explain how I got started with my widget development. We will create a very basic Word Finder widget, that just goes through the corpus (data) and tells you whether a word occurs in a corpus or not. This particular widget is meant to be a part of the \", _jsx(_components.a, {\n        href: \"https://github.com/biolab/orange3-text\",\n        children: \"Orange3-Text add-on\"\n      }), \" (so you need the add-on installed to try it), but the basic structure is the same for all widgets.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"First, I have to set the basic widget class.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"    class OWWordFinder(OWWidget):\\n        name = \\\"Word Finder\\\"\\n        description = \\\"Display whether a word is in a text or not.\\\"\\n        icon = \\\"icons/WordFinder.svg\\\"\\n        priority = 1\\n    \\n        inputs = [('Corpus', Table, 'set_data')]\\n        # This widget will have no output, but in case you want one, you define it as below.\\n        # outputs = [('Output Name', output_type, 'output_method')]\\n    \\n        want_control_area = False\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This sets up the description of the widget, icon, inputs and so on. \", _jsx(_components.code, {\n        children: \"want_control_area\"\n      }), \" is where we say we only want the main window. Both are on by default in Orange and this simply hides the empty control area on the widget's left side. If your widget has any parameters and controls, leave the control area on and place the buttons there.\"]\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/blog/2017-02-my-first-orange-widget/example-area.jpg\",\n      alt: \"\",\n      width: \"1234\",\n      height: \"978\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In \", _jsx(_components.code, {\n        children: \"__init__\"\n      }), \" we define widget properties (such as data and queried word) and set the view. I decided to go with a very simple design - I just put everything in the \", _jsx(_components.code, {\n        children: \"mainArea\"\n      }), \". For such a basic widget this might be ok, but otherwise you might want to dig deeper into models and use \", _jsx(_components.code, {\n        children: \"QTableView\"\n      }), \", \", _jsx(_components.code, {\n        children: \"QGraphicsScene\"\n      }), \" or something similar. Here we will build just the bare bones of a functioning widget.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"    def __init__(self):\\n            super().__init__()\\n    \\n            self.corpus = None    # input data\\n            self.word = \\\"\\\"        # queried word\\n    \\n            # setting the gui\\n            gui.widgetBox(self.mainArea, orientation=\\\"vertical\\\")\\n            self.input = gui.lineEdit(self.mainArea, self, '',\\n                                      orientation=\\\"horizontal\\\",\\n                                      label='Query:')\\n            self.input.setFocus()\\n            # run method self.search on every text change\\n            self.input.textChanged.connect(self.search)\\n            \\n            # place a text label in the mainArea\\n            self.view = QLabel()\\n            self.mainArea.layout().addWidget(self.view)\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Ok, this now sets the \", _jsx(_components.code, {\n        children: \"__init__\"\n      }), \": what the widget remembers and how it looks like. With our buttons in place, the widget needs some methods, too.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The first method will update the self.corpus attribute, when the widget receives an input.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"    def set_data(self, data=None):\\n            if data is not None and not isinstance(data, Corpus):\\n                self.corpus = Corpus.from_table(data.domain, data)\\n            self.corpus = data\\n            self.search()\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"At the end we called \", _jsx(_components.code, {\n        children: \"self.search()\"\n      }), \" method, which we already met in \", _jsx(_components.code, {\n        children: \"__init__\"\n      }), \" above. This method is key to our widget, as it will run the search every time the word changes. Moreover, it will run the method on the same query word when the widget is provided with a new data set, which is why we set it also in \", _jsx(_components.code, {\n        children: \"set_data()\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Ok, let's finally write this method.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"    def search(self):\\n            self.word = self.input.text()\\n            # self.corpus.tokens will run a default tokenizer, if no tokens are provided on the input\\n            result = any(self.word in doc for doc in self.corpus.tokens)\\n            self.view.setText(str(result))\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This is it. This is our widget. Good job. Creating a new widget can indeed be lot of fun. You can go from a quite basic widget to very intricate, depending on your sense of adventure.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Finally, you can get the \", _jsx(_components.a, {\n        href: \"https://gist.github.com/ajdapretnar/e66e1dbecef3bb59abd4137bf8c2ab77\",\n        children: \"entire widget code in gist\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/blog/2017-02-my-first-orange-widget/Screen-Shot-2017-02-23-at-10.41.27.png\",\n      alt: \"\",\n      width: \"1354\",\n      height: \"1032\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Happy programming, everyone! :)\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}