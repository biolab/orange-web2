{"pageProps":{"frontmatter":{"author":"Ajda P. Å½agar","date":"2025-03-28","draft":false,"title":"Finding semantic neighbors with Orange","thumbImage":"acm-small.png","frontPageImage":"acm-small.png","blog":["text mining","digital humanities","embedding"],"shortExcerpt":"Finding semantically similar documents in Orange helps digital humanists retrieve relevant documents in a large corpus.","longExcerpt":"Finding semantically similar documents in Orange helps digital humanists retrieve relevant documents in a large corpus."},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    ol: \"ol\",\n    li: \"li\",\n    strong: \"strong\",\n    em: \"em\",\n    a: \"a\"\n  }, _provideComponents(), props.components), {WindowScreenshot} = _components;\n  if (!WindowScreenshot) _missingMdxReference(\"WindowScreenshot\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      children: \"Context\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Recently, I attended a workshop on using AI, specifically text embeddings, in historical research. The workshop was held in the Hague and hosted by Pim Huijnen. His research group developed an interesting approach to retrieve relevant documents from a corpus. Imagine you'd like to study the concept of \\\"progress\\\" in political debates, but you don't want to limit your search to just the documents including the word \\\"progress.\\\" Instead, you would also like to include those mentioning \\\"progression\\\", \\\"advancement\\\", or \\\"development\\\".  You would also like to observe how this concept has changed through time.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To achieve this, Huijnen and colleagues suggest using existing word embedding models that consider the context of the word. The idea is that word embedding will differ depending on which words occur in their neighborhood. So if the word \\\"progress\\\" was originally mentioned more with, say, railway infrastructure, their early embeddings will be different to the later connection between \\\"progress\\\" and \\\"technology\\\". They propose:\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"selecting candidate documents based on keyword search.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"using BERT-based embeddings that capture the semantic meaning of the sentence to numerically represent the document\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"computing N closest neighbors to find semantically similar documents\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"observing the document landscape, and\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"observing how the association of the word with different concepts changes through time.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"How to do it in Orange?\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"It is possible to construct a part of their proposed workflow in Orange. We start with the \", _jsx(_components.strong, {\n        children: \"Datasets\"\n      }), \" widget to select \", _jsx(_components.em, {\n        children: \"Parlamint\"\n      }), \", a subset of parliamentary speeches from the UK. Next, we use \", _jsx(_components.strong, {\n        children: \"Corpus\"\n      }), \" to indicate the text variable (\", _jsx(_components.em, {\n        children: \"content\"\n      }), \" in our case) and embed the corpus with the \", _jsx(_components.strong, {\n        children: \"Document Embedding\"\n      }), \" multilingual sBERT model. We connect \", _jsx(_components.strong, {\n        children: \"Corpus\"\n      }), \" to \", _jsx(_components.strong, {\n        children: \"Corpus Viewer\"\n      }), \" to select candidate documents. For this example, we have selected \", _jsx(_components.em, {\n        children: \"\\\\bprogress\\\\b\"\n      }), \" regular expression that finds all the mentions of the word \", _jsx(_components.em, {\n        children: \"progress\"\n      }), \". We have 47 documents that match our query.\"]\n    }), \"\\n\", _jsx(WindowScreenshot, {\n      src: \"/blog/2025-03-semantic-neighbors/workflow1.png\",\n      width: \"938\",\n      height: \"224\",\n      src: \"/blog/2025-03-semantic-neighbors/__optimized-images__/workflow1.png\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Now for the neighbor search. We wish to retrieve documents similar to our candidate documents. In other words, we wish to find documents that refer to progress in some other way, not explicitly using the word \\\"progress\\\". We will use \", _jsx(_components.strong, {\n        children: \"Neighbors\"\n      }), \" to achieve this. We use \", _jsx(_components.em, {\n        children: \"cosine\"\n      }), \" distance to measure the similarity between documents and output 10 closest neighbors. Note that the input to Neighbors is a bit complicated. We need to input the \", _jsx(_components.em, {\n        children: \"Matching Data\"\n      }), \" from Corpus Viewer as a reference data set (what the output needs to be similar to) and \", _jsx(_components.em, {\n        children: \"Other Docs\"\n      }), \" as data (where the neighbors come from).\"]\n    }), \"\\n\", _jsx(WindowScreenshot, {\n      src: \"/blog/2025-03-semantic-neighbors/edit-links.png\",\n      width: \"1142\",\n      height: \"572\",\n      src: \"/blog/2025-03-semantic-neighbors/__optimized-images__/edit-links.png\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The Neighbors widget only outputs neighbors, so we have to use \", _jsx(_components.strong, {\n        children: \"Concatenate\"\n      }), \" to join the candidate documents to the newly found neighbors. We will also add the source information to know which documents come from the query and which are the neighbors, and add the information to meta variables.\"]\n    }), \"\\n\", _jsx(WindowScreenshot, {\n      src: \"/blog/2025-03-semantic-neighbors/concatenate.png\",\n      width: \"770\",\n      height: \"952\",\n      src: \"/blog/2025-03-semantic-neighbors/__optimized-images__/concatenate.png\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Next, we have to pass the data to yet another Corpus, because \", _jsx(_components.strong, {\n        children: \"Concatenate\"\n      }), \" output a Table, not a Corpus object. In \", _jsx(_components.strong, {\n        children: \"Corpus (1)\"\n      }), \" we once again set the text variable to \", _jsx(_components.em, {\n        children: \"content\"\n      }), \". Then we pass the data to \", _jsx(_components.strong, {\n        children: \"t-SNE\"\n      }), \", an embedding technique that maps documents in space based on the previously computed document embeddings. Finally, we pass the data to \", _jsx(_components.strong, {\n        children: \"Annotated Corpus Map\"\n      }), \" to discover document clusters and characterize them with representative words. Voila, a 2D dimensional map, where the dots represent the documents and their color their origin -- whether they were our candidate document or the found neighbor. It looks like most of the neighbors refer to the Northern Ireland. Typically, these refer to the progress in passing bills concerning Northern Ireland.\"]\n    }), \"\\n\", _jsx(WindowScreenshot, {\n      src: \"/blog/2025-03-semantic-neighbors/acm.png\",\n      width: \"1676\",\n      height: \"1250\",\n      src: \"/blog/2025-03-semantic-neighbors/__optimized-images__/acm.png\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Do it better\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.a, {\n        href: \"https://orangedatamining.com/examples/semantic-neighbors/semantic-neighbors.ows\",\n        children: \"full workflow\"\n      }), \" is available for download in the \", _jsx(_components.a, {\n        href: \"https://orangedatamining.com/examples/\",\n        children: \"Examples page\"\n      }), \".\"]\n    }), \"\\n\", _jsx(WindowScreenshot, {\n      src: \"/blog/2025-03-semantic-neighbors/workflow2.png\",\n      width: \"1818\",\n      height: \"368\",\n      src: \"/blog/2025-03-semantic-neighbors/__optimized-images__/workflow2.png\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This workflow, naturally, captures only a small part of the technique proposed by Huijnen et al. Most notably, neighbor search is based on entire documents, not just sentences that contain mentions of \\\"progress\\\". Sentence extraction could be achieved with the \", _jsx(_components.a, {\n        href: \"https://github.com/biolab/orange-scripts/blob/master/scripts/Text/sentences-to-corpus.py\",\n        children: \"dedicated Python Script\"\n      }), \" from our Scripts repository. Afterwards, filtering on sentences that contain only the word \\\"progress\\\" has to be repeated.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Next, UMAP functionality is still missing in Orange. t-SNE is still a good substitute for UMAP for producing 2D data maps.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Finally, observing instances through time is a bit cumbersome in Orange, but could be achieved with the \", _jsx(_components.strong, {\n        children: \"Time Slice\"\n      }), \" widget from the Timeseries add-on. For that, we would of course need a much bigger data set, not only 47 candidate speeches.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The good news is that the functionality is fully available in the Jupyter notebooks from the Semantics of Sustainability group's \", _jsx(_components.a, {\n        href: \"https://github.com/Semantics-of-Sustainability/tempo-embeddings\",\n        children: \"Github page\"\n      }), \". I was ever so glad to meet another group that believes in open science as much as we do!\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}},"thumbImage":{"width":600,"height":400,"src":"/blog/2025-03-semantic-neighbors/__optimized-images__/acm-small.png"}},"__N_SSG":true}