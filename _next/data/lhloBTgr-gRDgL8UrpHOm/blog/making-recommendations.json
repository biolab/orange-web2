{"pageProps":{"frontmatter":{"author":"SALVACARRION","date":"2016-08-19 20:42:59+00:00","draft":false,"title":"Making recommendations","blog":["addons","business intelligence","gsoc2016","orange3","recommender  system"],"oldUrl":"/blog/2016/08/19/making-recommendations/"},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    em: \"em\",\n    a: \"a\",\n    h3: \"h3\",\n    pre: \"pre\",\n    code: \"code\",\n    strong: \"strong\",\n    img: \"img\",\n    ol: \"ol\",\n    li: \"li\",\n    ul: \"ul\"\n  }, _provideComponents(), props.components), {Figure} = _components;\n  if (!Figure) _missingMdxReference(\"Figure\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.em, {\n        children: \"This is a guest blog from the Google Summer of Code project.\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Recommender systems are everywhere, we can find them on YouTube, Amazon, Netflix, iTunes,... This is because they are crucial component in a competitive retail services.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"How can I know what you may like if I have almost no information about you? The answer: taking \", _jsx(_components.a, {\n        href: \"https://en.wikipedia.org/wiki/Collaborative_filtering\",\n        children: \"Collaborative filtering (CF)\"\n      }), \" approaches. Basically, this means to combine all the little knowledge we have about users and/or items in order to build a grid of knowledge with which we make recommendation.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To help you with that, Biolab has written \", _jsx(_components.a, {\n        href: \"https://github.com/biolab/orange3-recommendation\",\n        children: \"Orange3-Recommendation\"\n      }), \" - an add-on for \", _jsx(_components.a, {\n        href: \"http://orange.biolab.si/download/\",\n        children: \"Orange3\"\n      }), \" to train recommendation models, cross-validate them and make predictions.\"]\n    }), \"\\n\", _jsx(_components.h3, {}), \"\\n\", _jsx(_components.h3, {\n      children: \"Input data\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"First things first. Orange3-Recommendation can read files in native tab-delimited format, or can load data from any of the major standard spreadsheet file type, like CSV and Excel. Native format starts with a header row with feature (column) names. Second header row gives the attribute type, which can be continuous, discrete, string or time. The third header line contains meta information to identify dependent features (class), irrelevant features (ignore) or meta features (meta).\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Here are the first few lines from a data set:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"        tid      user        movie       score\\n        string   discrete    discrete    continuous\\n        meta     row=1       col=1       class\\n        1        Breza       HarrySally  2\\n        2        Dana        Cvetje      5\\n        3        Cene        Prometheus  5\\n        4        Ksenija     HarrySally  4\\n        5        Albert      Matrix      4\\n        ...\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"The third row is mandatory in this kind of datasets\"\n      }), \"*, in order to know which attributes correspond to the users (row=1) and which ones to the items (col=1). For the case of big datasets, users and items must be specified as continuous attributes due to efficiency issues. (*Note: If the meta attributes \", _jsx(_components.em, {\n        children: \"row\"\n      }), \" or \", _jsx(_components.em, {\n        children: \"col\"\n      }), \", some simple heuristics will be applied: users=\", _jsx(_components.em, {\n        children: \"column 0\"\n      }), \", items=\", _jsx(_components.em, {\n        children: \"column 1\"\n      }), \", class=\", _jsx(_components.em, {\n        children: \"last column\"\n      }), \")\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Here are the first few lines from a data set :\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"        user            movie         score         tid\\n        continuous      continuous    continuous    time\\n        row=1           col=1         class         meta\\n        196             242           3             881250949\\n        186             302           3             891717742\\n        22              377           1             878887116\\n        244             51            2             880606923\\n        166             346           1             886397596\\n        298             474           4             884182806\\n        ...\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {}), \"\\n\", _jsx(_components.h3, {\n      children: \"Training a model\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This step is pretty simple. To train a model we have to load the data as is described above and connect it to the learner. (\", _jsx(_components.em, {\n        children: \"Don't forget to click apply\"\n      }), \")\"]\n    }), \"\\n\", _jsx(Figure, {\n      src: \"/blog/2016-08-making-recommendations/data-to-brismf.png\",\n      src: \"300\",\n      width: \"570\",\n      height: \"208\",\n      src: \"/blog/2016-08-making-recommendations/__webp-images__/data-to-brismf.webp\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If the model uses side information, we only need to add an extra file.\"\n    }), \"\\n\", _jsx(Figure, {\n      src: \"/blog/2016-08-making-recommendations/TrustSVD-1.png\",\n      src: \"300\",\n      width: \"686\",\n      height: \"462\",\n      src: \"/blog/2016-08-making-recommendations/__webp-images__/TrustSVD-1.webp\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In addition, we can set the parameters of our model by double-clicking it:\"\n    }), \"\\n\", _jsx(Figure, {\n      src: \"/blog/2016-08-making-recommendations/Screen-Shot-2016-08-22-at-15.49.56.png\",\n      src: \"400\",\n      width: \"826\",\n      height: \"1386\",\n      src: \"/blog/2016-08-making-recommendations/__webp-images__/Screen-Shot-2016-08-22-at-15.49.56.webp\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"By using a fixed seed, we make random numbers predictable. Therefore, this feature is useful if we want to compare results in a deterministic way.\"\n    }), \"\\n\", _jsx(_components.h3, {}), \"\\n\", _jsx(_components.h3, {\n      children: \"Cross-validation\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This is as simple as it seems. The only thing to point out is that side information must be connected to the model.\"\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/blog/2016-08-making-recommendations/__webp-images__/cv-recommendation.webp\",\n      alt: \"\",\n      width: \"1544\",\n      height: \"666\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Still, cross-validation is a robust way to see how our model is performing. I consider that it's a good idea to check how our model performs with respect to the baseline. This presents a negligible overload* in our pipeline and makes our analysis more solid. \", _jsx(_components.em, {\n        children: \"(*For 1,000,000 ratings, it can take 0.027s).\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"We can add a baseline leaner to \", _jsx(_components.a, {\n        href: \"/widget-catalog/evaluate/testandscore/\",\n        children: \"Test&Score\"\n      }), \" and select the model we want to apply.\"]\n    }), \"\\n\", _jsx(Figure, {\n      src: \"/blog/2016-08-making-recommendations/Baselines.png\",\n      src: \"300\",\n      width: \"662\",\n      height: \"774\",\n      src: \"/blog/2016-08-making-recommendations/__webp-images__/Baselines.webp\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Making recommendations\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The prediction flow is exactly the same as in \", _jsx(_components.a, {\n        href: \"http://orange.biolab.si\",\n        children: \"Orange3\"\n      }), \".\"]\n    }), \"\\n\", _jsx(Figure, {\n      src: \"/blog/2016-08-making-recommendations/Recommendation-predictions.png\",\n      src: \"400\",\n      width: \"1146\",\n      height: \"564\",\n      src: \"/blog/2016-08-making-recommendations/__webp-images__/Recommendation-predictions.webp\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Analyzing low-rank matrices\"\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/blog/2016-08-making-recommendations/__webp-images__/all-rank-dis.webp\",\n      alt: \"\",\n      width: \"2376\",\n      height: \"1420\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Once we've output the low-rank matrices, we can play around the vectors in those matrices to discover hidden relations or understand the known ones. For instance, here we plot vector 1 and 2 from the \", _jsx(_components.em, {\n        children: \"item-feature matrix\"\n      }), \" by simply connecting Data Table with selected instances to the widget \", _jsx(_components.a, {\n        href: \"/widget-catalog/visualize/scatterplot/\",\n        children: \"Scatter Plot\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/blog/2016-08-making-recommendations/__webp-images__/Visualizing-vectors.webp\",\n      alt: \"\",\n      width: \"2260\",\n      height: \"1664\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Using similar approaches we can discover pretty interesting things like similarity between movies or users, how movie genres relate with each other, changes in users' behavior, when the popularity of a movie has been raised due to a commercial campaign,... and many others.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Finally, a simple pipeline to do all of the above can be something like this:\"\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/blog/2016-08-making-recommendations/__webp-images__/workflow-recommendation.webp\",\n      alt: \"\",\n      width: \"2946\",\n      height: \"1694\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"On the left side we connected several models to \", _jsx(_components.a, {\n        href: \"/widget-catalog/evaluate/testandscore/\",\n        children: \"Test&Score\"\n      }), \" in order to cross-validate them. Later, we trained a \", _jsx(_components.a, {\n        href: \"http://orange3-recommendation.readthedocs.io/en/latest/widgets/svdplusplus.html\",\n        children: \"SVD++\"\n      }), \" model, made some predictions, got the low-rank matrices learnt by the model and plotted some vectors of the \", _jsx(_components.em, {\n        children: \"Item-feature matrix.\"\n      })]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Analysis (Advanced users)\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Here we've made a workflow (which can be downloaded \", _jsx(_components.a, {\n        href: \"/blog/2016-08-making-recommendations/Orange3-Workflow-Movielens100k.zip\",\n        children: \"here\"\n      }), \") to perform a really basic analysis on the results obtained through factoring the user and item feature matrices with \", _jsx(_components.a, {\n        href: \"http://orange3-recommendation.readthedocs.io/en/latest/widgets/brismf.html\",\n        children: \"BRISMF\"\n      }), \" over the \", _jsx(_components.a, {\n        href: \"http://grouplens.org/datasets/movielens/\",\n        children: \"movielens100k\"\n      }), \" dataset. \", _jsx(_components.em, {\n        children: \"(Note: Once downloaded, set the prepared datasets in the folder 'orange'. Probably you're gonna get a couple errors. Don't worry, it's normal. To solve it, apply the scripts sequentially but don't forget previously to select all the rows in the related Table.)\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Instead of explaining how this pipeline works, the best thing you can do is to download it and play with it.\"\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/blog/2016-08-making-recommendations/__webp-images__/Complex-flow.webp\",\n      alt: \"\",\n      width: \"2880\",\n      height: \"1800\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"One of the analysis you can do, is to plot the most popular movies across two first vectors of the matrix descomposition. Later, you can try to find clusters, tweak it a bit and find crossed relations (e.g. \", _jsx(_components.em, {\n        children: \"male/female\"\n      }), \" Vs._ action/drama)._\"]\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/blog/2016-08-making-recommendations/__webp-images__/Cluster-movies.webp\",\n      alt: \"\",\n      width: \"2692\",\n      height: \"1776\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Now let's focus on the scripting part.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Rating models\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In this tutorial we are going to train a \", _jsx(_components.a, {\n        href: \"http://orange3-recommendation.readthedocs.io/en/latest/scripting/rating.html#brismf\",\n        children: \"BRISMF\"\n      }), \" model.\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"First we \", _jsxs(_components.strong, {\n          children: [\"import \", _jsx(_components.em, {\n            children: \"Orange\"\n          }), \" and the learner\"]\n        }), \" that we want to use:\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"        import Orange\\n        from orangecontrib.recommendation import BRISMFLearner\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"2\",\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"After that, we have to \", _jsx(_components.strong, {\n          children: \"load a dataset\"\n        }), \":\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"        data = Orange.data.Table('movielens100k.tab')\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"3\",\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"Then we set the \", _jsx(_components.strong, {\n          children: \"learner parameters\"\n        }), \", and finally we \", _jsx(_components.strong, {\n          children: \"train it\"\n        }), \" passing the dataset as an argument (the returned value will be our model trained):\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"        learner = BRISMFLearner(num_factors=15, num_iter=25, learning_rate=0.07, lmbda=0.1)\\n        recommender = learner(data)\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"4\",\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"Finally, we can \", _jsx(_components.strong, {\n          children: \"make predictions\"\n        }), \" (in this case, for the first three pairs in the dataset):\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"        prediction = recommender(data[:3])\\n        print(prediction)\\n        >>> [ 3.79505151 3.75096513 1.293013 ]\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {}), \"\\n\", _jsx(_components.h3, {\n      children: \"Ranking models\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"At this point we can try something new, let's make recommendations for a dataset in which only binary relevance is available. For this case, \", _jsx(_components.a, {\n        href: \"http://orange3-recommendation.readthedocs.io/en/latest/scripting/ranking.html\",\n        children: \"CLiMF\"\n      }), \" is model that will suit our needs.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"    import Orange\\n    import numpy as np\\n    from orangecontrib.recommendation import CLiMFLearner\\n    \\n    # Load data\\n    data = Orange.data.Table('epinions_train.tab')\\n    \\n    # Train recommender\\n    learner = CLiMFLearner(num_factors=10, num_iter=10, learning_rate=0.0001, lmbda=0.001)\\n    recommender = learner(data)\\n    \\n    # Make recommendations\\n    recommender(X=5)\\n    >>> [ 494,   803,   180, ..., 25520, 25507, 30815]\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Later, we can score the model. In this case we're using the \", _jsx(_components.em, {\n        children: \"MeanReciprocalRank:\"\n      })]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"    import Orange\\n    \\n    # Load test\\n    dataset testdata = Orange.data.Table('epinions_test.tab') \\n    \\n    # Sample users \\n    num_users = len(recommender.U)\\n    num_samples = min(num_users, 1000) # max. number to sample\\n    users_sampled = np.random.choice(np.arange(num_users), num_samples) \\n    \\n    # Compute Mean Reciprocal Rank (MRR) \\n    mrr, _ = recommender.compute_mrr(data=testdata, users=users_sampled) \\n    print('MRR: %.4f' % mrr) \\n    >>> MRR: 0.3975\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {}), \"\\n\", _jsx(_components.h3, {\n      children: \"SGD optimizers\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This add-on includes several configurations that can be used to modify the updates on the low rank matrices during the stochastic gradient descent optimization.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"http://orange3-recommendation.readthedocs.io/en/latest/scripting/optimizers.html#stochastic-gradient-descent\",\n          children: \"SGD\"\n        }), \": Classical SGD update.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"http://orange3-recommendation.readthedocs.io/en/latest/scripting/optimizers.html#momentum\",\n          children: \"Momentum\"\n        }), \": SGD with inertia.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"http://orange3-recommendation.readthedocs.io/en/latest/scripting/optimizers.html#nesterov-s-accelerated-gradient\",\n          children: \"Nesterov momentum\"\n        }), \": A Momentum that \\\"looks ahead\\\".\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"http://orange3-recommendation.readthedocs.io/en/latest/scripting/optimizers.html#adagradient\",\n          children: \"AdaGrad\"\n        }), \": Optimizer that adapts its learning rating during the process.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"http://orange3-recommendation.readthedocs.io/en/latest/scripting/optimizers.html#rmsprop\",\n          children: \"RMSProp\"\n        }), \": \\\"Leaky\\\" AdaGrad.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"http://orange3-recommendation.readthedocs.io/en/latest/scripting/optimizers.html#adadelta\",\n          children: \"AdaDelta\"\n        }), \": Extension of Adagrad that seeks to reduce its aggressive.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"http://orange3-recommendation.readthedocs.io/en/latest/scripting/optimizers.html#adam\",\n          children: \"Adam\"\n        }), \": Similar to AdaGrad and RMSProp but with an exponentially decaying average of past gradients.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"http://orange3-recommendation.readthedocs.io/en/latest/scripting/optimizers.html#adamax\",\n          children: \"Adamax\"\n        }), \": Similar to Adam, but taking the maximum between the gradient and the velocity.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Do you want to learn more about this? Check our \", _jsx(_components.a, {\n        href: \"http://orange3-recommendation.readthedocs.io\",\n        children: \"documentation\"\n      }), \"!\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}},"__N_SSG":true}