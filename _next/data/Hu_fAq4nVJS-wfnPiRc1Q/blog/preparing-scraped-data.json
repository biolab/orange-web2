{"pageProps":{"frontmatter":{"author":"AJDA","date":"2017-01-23 12:29:20+00:00","draft":false,"title":"Preparing Scraped Data","type":"blog","blog":["addons","analysis","data","dataloading","examples","python","scripting"]},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    strong: \"strong\",\n    a: \"a\",\n    pre: \"pre\",\n    code: \"code\",\n    em: \"em\",\n    img: \"img\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"One of the key questions of every data analysis is how to get the data and put it in the right form(at). In this post I'll show you how to easily get the data from the web and transfer it to a file Orange can read.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Related:\"\n      }), \" \", _jsx(_components.a, {\n        href: \"/blog/2015/08/07/creating-a-new-data-table-in-orange-through-python/\",\n        children: \"Creating a new data table in Orange through Python\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"First, we'll have to do some scripting. We'll use a couple of Python libraries - \", _jsx(_components.a, {\n        href: \"https://docs.python.org/3.5/library/urllib.request.html\",\n        children: \"urllib.requests\"\n      }), \" fetching the data, \", _jsx(_components.a, {\n        href: \"https://www.crummy.com/software/BeautifulSoup/bs4/doc/\",\n        children: \"BeautifulSoup\"\n      }), \" for reading it, \", _jsx(_components.a, {\n        href: \"https://docs.python.org/3.5/library/csv.html\",\n        children: \"csv\"\n      }), \" for writing it and \", _jsx(_components.a, {\n        href: \"https://docs.python.org/3.5/library/re.html\",\n        children: \"regular expressions\"\n      }), \" for extracting the right data.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"    from urllib.request import urlopen\\n    from bs4 import BeautifulSoup\\n    import csv\\n    import re\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Ok, we've imported the all the libraries we'll need. Now we will scrape the data from our own blog to see how many posts we've written throughout the years.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"    html = urlopen('http://blog.biolab.si')\\n    soup = BeautifulSoup(html.read(), 'lxml')\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The first line opens the address of the site we want to scrape. In our case this is our blog. The second line retrieves a html response from the site, which is our raw text. It looks like this:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"    <aside id=\\\"archives-2\\\" class=\\\"widget widget_archive\\\"><h3 class=\\\"widget-title\\\">Archives</h3>\\n    <ul>\\n       <li><a href='http://blog.biolab.si/2017/01/'>January 2017</a>&nbsp;(1)</li>\\n       <li><a href='http://blog.biolab.si/2016/12/'>December 2016</a>&nbsp;(3)</li>\\n       <li><a href='http://blog.biolab.si/2016/11/'>November 2016</a>&nbsp;(4)</li>\\n       <li><a href='http://blog.biolab.si/2016/10/'>October 2016</a>&nbsp;(3)</li>\\n       <li><a href='http://blog.biolab.si/2016/09/'>September 2016</a>&nbsp;(2)</li>\\n       <li><a href='http://blog.biolab.si/2016/08/'>August 2016</a>&nbsp;(5)</li>\\n       <li><a href='http://blog.biolab.si/2016/07/'>July 2016</a>&nbsp;(3)</li>....\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Ok, html is nice, but we can't really do data analysis with this. We will have to transform this output into something sensible. How about .csv, a simple comma-demilited format Orange can recognize?\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"    with open('scraped.csv', 'w') as csvfile:\\n        csvwriter = csv.writer(csvfile, delimiter=',')\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"We created a new file called '\", _jsx(_components.em, {\n        children: \"scraped.csv\"\n      }), \"' to which we will write our content ('w' parameter means write). Then we defined the writer and set the delimiter to comma.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now we need to add the header row, so Orange will know what are the column names. We add this just after csvwriter variable.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"    csvwriter.writerow([\\\"Date\\\", \\\"No_of_Blogs\\\"])\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Now we have two columns, one named 'Date' and the other 'No_of_Blogs'. The final step is to extract the data. We have a bunch of lines in html, but the one we're interested in is in a section 'aside' and has an id '\", _jsx(_components.em, {\n        children: \"archives-2\"\n      }), \"'. We will first extract only this section (\", _jsx(_components.em, {\n        children: \".find(id='archives-2'\"\n      }), \") and get all the lines of the archive with the tag 'li' (\", _jsx(_components.em, {\n        children: \".find_all('li')\"\n      }), \"):\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"    for item in soup.find(id=\\\"archives-2\\\").find_all('li'):\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This is the result of \", _jsx(_components.em, {\n        children: \"print(item)\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"    <li><a href=\\\"http://blog.biolab.si/2017/01/\\\">January 2017</a> (1)</li>\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Now we need to get the actual content from each line. The first part we need is the date of the archived content. Orange can read dates, but they need to come in the right format. We will extract the date from \", _jsx(_components.em, {\n        children: \"href\"\n      }), \" part with \", _jsx(_components.em, {\n        children: \"item.a.get('href')\"\n      }), \". Then we need to extract only digits from it as we're not interested in the rest of the link. We do this with Regex for finding digits:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"    date = re.findall(r'\\\\d+', item.a.get('href'))\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Regex's \", _jsx(_components.em, {\n        children: \"findall\"\n      }), \" function returns a list, in our case containing two items - the year and month of archived content. The second part of our data is the number of blogs archived in a particular month. We will again extract this with a Regex digit search, but this time we will be extracting data from the actual content - '\", _jsx(_components.em, {\n        children: \"item.contents[1]\"\n      }), \"'.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"    digits = re.findall(r'\\\\d+', item.contents[1])\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Finally, we need to write each line to a .csv file we created above.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"    csvwriter.writerow([\\\"%s-%s-01\\\" % (date[0], date[1]), digits[0]])\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Here, we formatted the date into an ISO-standard format Orange recognizes as time variable (\", _jsx(_components.em, {\n        children: \"\\\"%s-%s-01\\\" % (date[0], date[1])\"\n      }), \"), while the second part is simply a count of our blog posts.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This is the entire code:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"    from urllib.request import urlopen\\n    from bs4 import BeautifulSoup\\n    import csv\\n    import re\\n    \\n    html = urlopen('http://blog.biolab.si')\\n    soup = BeautifulSoup(html.read(), 'lxml')\\n    \\n    with open('scraped.csv', 'w') as csvfile:\\n        csvwriter = csv.writer(csvfile, delimiter=',')\\n        csvwriter.writerow([\\\"Date\\\", \\\"No_of_Blogs\\\"])\\n        for item in soup.find(id=\\\"archives-2\\\").find_all('li'):\\n            date = re.findall(r'\\\\d+', item.a.get('href'))\\n            digits = re.findall(r'\\\\d+', item.contents[1])\\n            csvwriter.writerow([\\\"%s-%s-01\\\" % (date[0], date[1]), digits[0]])\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Related:\"\n      }), \" \", _jsx(_components.a, {\n        href: \"/blog/2016-06-10-scripting-with-time-variable/\",\n        children: \"Scripting with Time Variable\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now let's load this in Orange. File widget can easily read .csv formats and also correctly identifies the two column types, datetime and numeric. A quick glance into the Data Table...\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/blog/2017-01-preparing-scraped-data/Screen-Shot-2017-01-23-at-12.54.12.png\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Everything looks ok. We can use \", _jsx(_components.a, {\n        href: \"https://github.com/biolab/orange3-timeseries\",\n        children: \"Timeseries add-on\"\n      }), \" to inspect how many blogs we've written each month since 2010. Connect \", _jsx(_components.strong, {\n        children: \"As Timeseries\"\n      }), \" widget to File. Orange will automatically suggest to use Date as our time variable. Finally, we'll plot the data with \", _jsx(_components.strong, {\n        children: \"Line Chart\"\n      }), \". This is the curve of our blog activity.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/blog/2017-01-preparing-scraped-data/Screen-Shot-2017-01-23-at-12.54.53.png\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/blog/2017-01-preparing-scraped-data/Screen-Shot-2017-01-23-at-12.55.14.png\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The example is extremely simple. A somewhat proficient user can extract much more interesting data than a simple blog count, but one always needs to keep in mind the legal aspects of web scraping. Nevertheless, this is a popular and fruitful way to extract and explore the data!\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}