{"pageProps":{"frontmatter":{"author":"Žan Mervič","date":"2023-09-19 02:00:00+00:00","draft":false,"title":"Orange Fairness - Equal Odds Postprocessing","thumbImage":"2023-09-19-fairness-equal-odds-postprocessing.png","frontPageImage":"2023-09-19-fairness-equal-odds-postprocessing.png","blog":["fairness","equal odds postprocessing"],"shortExcerpt":"Explore the Equal Odds Postprocessing widget in Orange, designed to fine-tune your model's fairness. We explain how the algorithm operates and showcase its effectiveness with an example using the German credit dataset.","longExcerpt":"In this blog, we delve into the Equal Odds Postprocessing widget, a tool designed to enhance fairness in machine learning models. We break down how the algorithm works by modifying predictions to meet Equalized Odds criteria. Using a real-world example with the German credit dataset, we demonstrate its efficacy in improving fairness metrics while marginally affecting accuracy."},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    h3: \"h3\",\n    code: \"code\",\n    ul: \"ul\",\n    li: \"li\",\n    h2: \"h2\"\n  }, _provideComponents(), props.components), {WindowScreenshot} = _components;\n  if (!WindowScreenshot) _missingMdxReference(\"WindowScreenshot\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"In the \", _jsx(_components.a, {\n        href: \"/blog/2023-09-19-fairness-adversarial-debiasing/\",\n        children: \"previous blog post\"\n      }), \", we discussed the Adversarial Debiasing model, a bias-aware model. This blog post will discuss the Equal Odds Postprocessing widget, a bias-aware post-processor, which can be used with any model to mitigate bias in its predictions.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Equal Odds Postprocessing:\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.a, {\n        href: \"https://arxiv.org/abs/1610.02413\",\n        children: \"Equal Odds Postprocessing\"\n      }), \" widget is a post-processing type of fairness mitigation algorithm for supervised learning. It modifies the predictions of any given classifier to meet certain fairness criteria, specifically focusing on \\\"Equalized Odds\\\" or more relaxed criteria like Equal Opportunity. Because it is a post-processing algorithm, it is versatile and can be used with most models, unlike some pre-processing or in-processing algorithms.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The Equalized Odds Postprocessing widget introduces a unique functionality in the Orange environment. It works similarly to other Orange widgets representing models, except it also expects a learner as an input.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"It works by first fitting the learner to the training data, creating a model, and using it to get the predictions. It then uses these predictions to fit the Equalized Odds Postprocessing algorithm from the \", _jsx(_components.a, {\n        href: \"https://aif360.res.ibm.com/\",\n        children: \"AIF360\"\n      }), \" library, which creates a post-processor. This post-processor is then used to adjust the model's predictions on the test data. The result is a model that has been adjusted to meet the fairness criteria of Equalized Odds.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The Equalized Odds Postprocessing algorithm works by solving a linear program with some constraints and the following objective function:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.code, {\n        children: \"c = [fpr_0 - tpr_0, tnr_0 - fnr_0, fpr_1 - tpr_1, tnr_1 - fnr_1]\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Where \", _jsx(_components.code, {\n        children: \"fpr\"\n      }), \", \", _jsx(_components.code, {\n        children: \"tpr\"\n      }), \", \", _jsx(_components.code, {\n        children: \"tnr\"\n      }), \", and \", _jsx(_components.code, {\n        children: \"fnr\"\n      }), \" are the false positive, true positive, true negative, and false negative rates for privileged (\", _jsx(_components.code, {\n        children: \"0\"\n      }), \") and unprivileged (\", _jsx(_components.code, {\n        children: \"1\"\n      }), \") groups.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The algorithm then finds the optimal solution to the linear program, which results in a set of probabilities with which to flip the model's predictions to equalize the odds of being correctly or incorrectly classified for both privileged and unprivileged groups:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"sp2p\"\n        }), \": From positive to negative for the privileged group.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"sn2p\"\n        }), \": From negative to positive for the privileged group.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"op2p\"\n        }), \": From positive to negative for the unprivileged group.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"on2p\"\n        }), \": From negative to positive for the unprivileged group.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Orange use case\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now that we know how the Equal Odds Postprocessing widget works and how to use it let us look at a real-world example for a classification task.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"For this example, we will use the \", _jsx(_components.a, {\n        href: \"http://archive.ics.uci.edu/dataset/144/statlog+german+credit+data\",\n        children: \"German credit dataset\"\n      }), \", which we have used \", _jsx(_components.a, {\n        href: \"/blog/2023/2023-08-25-fairness-reweighing-preprocessor/\",\n        children: \"before\"\n      }), \". The German Credit is a dataset related to bank loans. The main goal is to assess an individual's credit risk - whether a person is a good or bad credit risk. Unlike previously, we will not use the default fairness attributes that come with the dataset. Instead, we will use the age attribute, which we first discretize to two groups, younger and older than 26. We will set the older group as the privileged group.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We will train two Logistic Regression models, one with and one without the Equal Odds Postprocessing widget, and compare the predictions of these models.\"\n    }), \"\\n\", _jsx(WindowScreenshot, {\n      src: \"/blog/2023-09-fairness-equal-odds-postprocessing/2023-09-19-fairness-equal-odds-postprocessing-use-case.png\",\n      width: \"957\",\n      height: \"475\",\n      src: \"/blog/2023-09-fairness-equal-odds-postprocessing/__webp-images__/2023-09-19-fairness-equal-odds-postprocessing-use-case.webp\"\n    }), \"\\n\", _jsx(WindowScreenshot, {\n      src: \"/blog/2023-09-fairness-equal-odds-postprocessing/2023-09-19-fairness-equal-odds-postprocessing-scores.png\",\n      width: \"845\",\n      height: \"458\",\n      src: \"/blog/2023-09-fairness-equal-odds-postprocessing/__webp-images__/2023-09-19-fairness-equal-odds-postprocessing-scores.webp\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The results show that the model using the Equal Odds Postprocessing widget has better fairness metrics than the model without it. Equal Odds Difference and Average Odds Difference are the main objectives of the Equal Odds Postprocessing algorithm, and we can see that they are much closer to zero when using the widget. We can also see that the Disparate Impact and Statistical Parity Difference metrics are much closer to their ideal values, which is a beneficial side effect rather than a direct result of the algorithm's optimization process and is not guaranteed to happen in all cases.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We can also see that the model's accuracy using the Equal Odds Postprocessing widget is slightly lower than without it. This is expected because the model is now not only trying to be accurate but also fair. This balance is a necessary trade-off we accept when we want to remove bias.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"When using the Equal Odds Postprocessing, it is worth noting that the AUC value is not an accurate representation of the model's performance. This is because the Equal Odds Postprocessing algorithm changes only the predictions of the model, not the prediction probabilities. This means the AUC value would be calculated from the original model's prediction probabilities, not the adjusted ones. We have decided to alter the prediction probabilities when using the Equal Odds Postprocessing widget to 1 if the prediction is of the positive class and 0 otherwise. This is done to ensure that the AUC value is calculated from the adjusted predictions, which is a more accurate representation of the model's performance but still not a perfect one.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Next, let us look at the mosaic display widget. We will use it to show the True Positive Rate for each group and thus the Equal Opportunity Difference metric, which is the difference of the True Positive Rates between unprivileged and privileged groups. To do this, we first had to use the Select Rows widget to keep only the instances with a positive class because we are not interested in the True Negative Rate. This was the result:\"\n    }), \"\\n\", _jsx(WindowScreenshot, {\n      src: \"/blog/2023-09-fairness-equal-odds-postprocessing/2023-09-19-fairness-equal-odds-postprocessing-mosaic-bias.png\",\n      width: \"752\",\n      height: \"667\",\n      src: \"/blog/2023-09-fairness-equal-odds-postprocessing/__webp-images__/2023-09-19-fairness-equal-odds-postprocessing-mosaic-bias.webp\"\n    }), \"\\n\", _jsx(WindowScreenshot, {\n      src: \"/blog/2023-09-fairness-equal-odds-postprocessing/2023-09-19-fairness-equal-odds-postprocessing-mosaic-debias.png\",\n      width: \"755\",\n      height: \"666\",\n      src: \"/blog/2023-09-fairness-equal-odds-postprocessing/__webp-images__/2023-09-19-fairness-equal-odds-postprocessing-mosaic-debias.webp\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In the visualizations, each column's red and blue parts represent the true positive and false negative rates, respectively, for each group. You can ignore the width of the columns as that represents the number of instances in each group, which is irrelevant to us.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In the first visualization, which represents predictions from the model without debiasing, we can see that the privileged group (≥ 26) has a higher True Positive Rate than the unprivileged group (< 26). This can be considered unfair towards the unprivileged group because it means a loan candidate from the unprivileged group is more likely to be falsely rejected, because of the higher false negative rate, than a loan candidate from the privileged group.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In the second visualization, representing predictions from the model with debiasing, we can see that the True Positive Rate for the privileged group has decreased and is now almost equal to the True Positive Rate for the unprivileged group. While this means the model is now less accurate for the privileged group, it is as accurate as it is for the unprivileged group, which could be considered a fairer outcome.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}},"__N_SSG":true}