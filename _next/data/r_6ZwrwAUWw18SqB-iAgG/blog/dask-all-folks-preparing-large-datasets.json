{"pageProps":{"frontmatter":{"author":"Noah Novšak","date":"2023-10-24","draft":false,"title":"Dask all Folks: Preparing Large Datasets","thumbImage":"2023-10-24-dask-all-folks.png","frontPageImage":"2023-10-24-dask-all-folks.png","blog":["dask","development"],"shortExcerpt":"Preparing large HDF5 datasets that load into Orange as on-disk data.","longExcerpt":"Preparing large HDF5 datasets that load into Orange as on-disk data. This post outlines the specifics of the HDF5 format used by Orange and provides Python code that will help you prepare your own large datasets.","oldUrl":"/blog/2023/2023-10-24-dask-all-folks/"},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    code: \"code\",\n    em: \"em\",\n    pre: \"pre\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"Today, we will delve into the exciting world of Dask once again, and explore how to finally bring your own data into Orange. Or, more precisely, into an \", _jsx(_components.a, {\n        href: \"https://github.com/biolab/orange3/wiki/Orange-with-Dask\",\n        children: \"experimental version of Orange that supports Dask\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If you've already set up your data as an Orange Table and you would just like to re-encode it to better support dask, then all you have to do is export it again as a \", _jsx(_components.code, {\n        children: \".hdf5\"\n      }), \" file. This is done either with the \", _jsx(_components.em, {\n        children: \"Save Data\"\n      }), \" widget (choose \\\"Orange on-disk data\\\" as the file type) or in \", _jsx(_components.em, {\n        children: \"python\"\n      }), \" like so:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [\"table = Table(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'my_data.tab'\"\n        }), \")\\ntable.save(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'my_data.hdf5'\"\n        }), \")\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Simple as that, end of blog, see you next time!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Well, not quite. For everyone that has a bunch of data in some other format, it's not quite as simple. So here's a short guide on preparing your data for Orange.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"First of all I'll assume your data can be read in python into something resembling a \", _jsx(_components.a, {\n        href: \"https://numpy.org/\",\n        children: \"numpy\"\n      }), \" array. If that is not the case, your first step will be to make it so. Next, in addition to the array you will also need to make a \", _jsx(_components.em, {\n        children: \"domain\"\n      }), \" for your data. That is where we store all the extra information that describes the contents of your data (feature names, types, target variables, etc.).\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-meta\",\n          children: \">>> \"\n        }), \"table = Table(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'heart_disease'\"\n        }), \")\\n\", _jsx(_components.span, {\n          className: \"hljs-meta\",\n          children: \">>> \"\n        }), \"table.domain.attributes\\n(ContinuousVariable(name=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'age'\"\n        }), \", number_of_decimals=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"),\\n DiscreteVariable(name=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'gender'\"\n        }), \", values=(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'female'\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'male'\"\n        }), \")),\\n...\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Usually in a \", _jsx(_components.code, {\n        children: \".csv\"\n      }), \" or \", _jsx(_components.code, {\n        children: \".tab\"\n      }), \" file we would write this information in the header (the first or first three rows). But the \", _jsx(_components.a, {\n        href: \"https://www.hdfgroup.org/solutions/hdf5\",\n        children: \"HDF5\"\n      }), \" format is somewhat different. It is very flexible and allows information to be stored in many different ways. So we've had to come up with a consistent way to save this information that is as true to the internal structure of our table a possible and simple to implement even outside orange. What we've settled on (depicted in the diagram below) is to make separate arrays to store the raw data, and an extra group to hold the additional information.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-html\",\n        children: \"├── X (Data)\\n├── Y (Class Data)\\n├── metas (Meta Data)\\n│   ├── 0 (Column 1)\\n│   ├── 1 (Column 2)\\n│   └── ... (Additional columns)\\n└── domain\\n    ├── attributes/class_vars/metas (Domain)\\n    └── attributes_args/class_vars_args/metas_args (Optional)\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Now let's try to apply this idea on an actual dataset! The simplest approach is to use a library like \", _jsx(_components.a, {\n        href: \"https://www.h5py.org/\",\n        children: \"h5py\"\n      }), \", this way it boils down to just a couple lines of code. First we can save our data arrays, (note that due to data types the \", _jsx(_components.em, {\n        children: \"metas\"\n      }), \" array is split up and saved by columns).\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"with\"\n        }), \" h5py.File(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'my_data.hdf5'\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'w'\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" f:\\n    f.create_dataset(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'X'\"\n        }), \", data=x_array)\\n    f.create_dataset(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Y'\"\n        }), \", data=y_array)\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" i \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" data_metas.shape[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"]:\\n        f.create_dataset(\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"f'metas/\", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"{i}\"\n          }), \"'\"]\n        }), \", data=metas_array[:, i])\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The next step is to make and store our domain. We'll have to make separate arrays for each of our attributes, class variables and meta attributes, and save them with the appropriate names. These 'domain' arrays should consist of two columns, indicating the name and type of each feature (each row representing one column of data).\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [\"attributes = np.array(\\n    [[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'age'\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'c'\"\n        }), \"], \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# ContinuousVariable(name='age')\"\n        }), \"\\n     [\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'gender'\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'d'\"\n        }), \"], \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# DiscreteVariable(name='gender')\"\n        }), \"\\n     ...],\\n    dtype=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'S'\"\n        }), \"\\n)\\nclass_vars = ...\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"with\"\n        }), \" h5py.File(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'my_data.hdf5'\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'r+'\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" f:\\n    domain = f.create_group(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'domain'\"\n        }), \")\\n    domain.create_dataset(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'attributes'\"\n        }), \", data=attributes)\\n    domain.creat_dataset(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'class_vars'\"\n        }), \", data=class_vars)\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Remember the \", _jsx(_components.em, {\n        children: \"heart-disease\"\n      }), \" table from the example above? Well you can see that the domain contains a little bit more than just the name and type of variables. Continuous variables can specify how accurate they are and discrete variables can also represent non-numeric data by specifying values. These parameters can be saved in our domain in seperate (optional) arrays. Because this additional information can be quite complex and varied though, we decided the most reasonable way to save them is to use \", _jsx(_components.a, {\n        href: \"https://www.json.org/json-en.html\",\n        children: \"json\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [\"attributes_args = np.array(\\n    [[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'{number_of_decimals: 0}'\"\n        }), \"],\\n     [\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'{values: (\\\"female\\\", \\\"male\\\")}'\"\n        }), \"],\\n     ...],\\n    dtype=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'S'\"\n        }), \"\\n)\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"with\"\n        }), \" h5py.File(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'my_data.hdf5'\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'r+'\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" f:\\n    domain = f[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'domain'\"\n        }), \"]\\n    domain.create_dataset(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'attributes_args'\"\n        }), \", data=attributes_args)\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"That's it! Now you can create your own \", _jsx(_components.code, {\n        children: \".hdf5\"\n      }), \" datasets and start processing them in Orange. Remember, you will need the experimental Orange version from the \", _jsx(_components.em, {\n        children: \"dask\"\n      }), \" branch: \", _jsx(_components.a, {\n        href: \"https://github.com/biolab/orange3/wiki/Orange-with-Dask\",\n        children: \"see installation instructions\"\n      }), \".\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"thumbImage":{"width":1024,"height":587,"src":"/blog/2023-10-dask-all-folks/__optimized-images__/2023-10-24-dask-all-folks.png"}},"__N_SSG":true}