{"pageProps":{"sections":[{"title":"Add-ons Extend Functionality","image":{"width":275,"height":576,"src":"/home/sections/add_ons.png"},"video":"OANsA6fMJKg?start=6","weight":50,"excerpt":null,"mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_components.p, {\n    children: [\"Use various add-ons available within Orange to mine data from external data sources, perform natural language processing and text mining, conduct network analysis, infer frequent itemset and do association rules mining. Additionally, bioinformaticians and molecular biologists can use Orange to rank genes by their differential expression and perform enrichment analysis. Check out also Orange cousins \", _jsx(_components.a, {\n      href: \"https://singlecell.biolab.si/\",\n      children: \"Single Cell\"\n    }), \" and \", _jsx(_components.a, {\n      href: \"https://quasar.codes/\",\n      children: \"Quasar\"\n    }), \".\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},{"title":"Interactive Data Visualization","image":{"width":808,"height":445,"src":"/home/sections/interactive_data_visualization.png"},"learnMore":true,"weight":20,"excerpt":"Perform simple data analysis with clever data visualization. Explore statistical distributions, box plots and scatter plots, or dive deeper with decision trees, hierarchical clustering, heatmaps, MDS and linear projections. Even your multidimensional data can become sensible in 2D, especially with clever attribute ranking and selections.","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h2: \"h2\"\n  }, _provideComponents(), props.components), {Figure} = _components;\n  if (!Figure) _missingMdxReference(\"Figure\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"Orange is all about data visualizations that help to uncover hidden data patterns, provide intuition behind data analysis procedures or support communication between data scientists and domain experts. Visualization widgets include scatter plot, box plot and histogram, and model-specific visualizations like dendrogram, silhouette plot, and tree visualizations, just to mention a few. Many other visualizations are available in add-ons and include visualizations of networks, word clouds, geographical maps, and more.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We take care to make Orange visualizations interactive: you can select data points from a scatter plot, a node in the tree, a branch in the dendrogram. Any such interaction will instruct visualization to send out a data subset that corresponds to the selected part of visualization. Consider the combination of a scatter plot and classification tree below. Scatter plot shows all the data, but highlights the data subset that corresponds to the selected node in the classification tree.\"\n    }), \"\\n\", _jsx(Figure, {\n      src: \"/images/features/vis/tree-selection-scatterplot.thumb.png\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Great Visualizations\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Orange includes many standard visualizations. Scatter plot is great for visualizing correlations between pair of attributes, box plot for displaying basic statistics, heat map to provide an overview across entire data set, and projection plots like MDS for plotting the multinomial data in two dimensions.\"\n    }), \"\\n\", _jsx(Figure, {\n      src: \"/images/features/vis/collage-visualizations.thumb.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Besides visualizations one would expect in a data mining suite, Orange includes some great extras that you may not find in other packages. These include widgets for silhouette plot to analyze the results of clustering, mosaic and Sieve diagram to discover feature interactions, and Pythagorean tree visualization for classification trees and forests.\"\n    }), \"\\n\", _jsx(Figure, {\n      src: \"/images/features/vis/advanced-visualizations.thumb.png\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Exploratory Data Analysis\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Interactive visualizations enable exploratory data analysis. One can select interesting data subsets directly from plots, graphs and data tables and mine them in them downstream widgets. For example, select a cluster from the dendrogram of hierarchical clustering and map it to a 2D data presentation in the MDS plot. Or check their values of in the data table. Or observe the spread of its feature values in a box plot. Open all these windows at once and see how the changes in your selection affect other widgets. Or, for another example, cross-validate logistic regression on a data set and map some of the misclassifications to the two-dimensional projection. It is easy to turn Orange into a tool where domain experts can explore their data even if they lack insights in underlying statistics or machine learning.\"\n    }), \"\\n\", _jsx(Figure, {\n      src: \"/images/features/vis/misclass-exploratory.thumb.png\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Intelligent Visualizations\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Sometimes there are just too many choices. Say, when data has many features, which feature pair should we visualize in a scatter plot to provide most information? Intelligent visualization comes to the rescue! In Orange's scatter plot, this is called Score Plots. When class information is provided, Score Plots finds projections with best class separation. Consider brown-selected data set (comes with Orange) and its 79 features. There are 3,081 (79*78/2) different features pairs, way too many to check them manually, but there are only a few feature combinations that yield a great scatter plot. Score Plots finds them all, and allows us to browse through them.\"\n    }), \"\\n\", _jsx(Figure, {\n      src: \"/images/features/vis/projection-ranking.thumb.png\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Reporting\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Finally, we can include the most important visualizations, statistics and information about the models into the report with a single click. Orange includes clever reporting where you can access workflow history for every widget and visualization directly from the report.\"\n    }), \"\\n\", _jsx(Figure, {\n      src: \"/images/features/vis/report.thumb.png\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}},{"title":"Visual Programming","image":{"width":629,"height":236,"src":"/home/sections/visual_programming.png"},"learnMore":true,"weight":30,"video":"lb-x36xqJ-E?start=6","excerpt":"Interactive data exploration for rapid qualitative analysis with clean visualizations. Graphic user interface allows you to focus on exploratory data analysis instead of coding, while clever defaults make fast prototyping of a data analysis workflow extremely easy. Place widgets on the canvas, connect them, load your datasets and harvest the insight!","mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h2: \"h2\",\n    br: \"br\"\n  }, _provideComponents(), props.components), {Figure} = _components;\n  if (!Figure) _missingMdxReference(\"Figure\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"Orange is a great data mining tool for beginners as well as for expert data scientists. Thanks to its user interface users can focus on data analysis instead on laborious coding, making a construction of complex data analytics pipelines simple.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Component-Based Data Mining\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In Orange, data analysis is done by stacking components into workflows. Each component, called a widget, embeds some data retrieval, preprocessing, visualization, modeling or evaluation task. Combining different widgets in a workflow enables you to build comprehensive data analysis schemas as you go. With a large library of widgets you won't be short for choice. Additional widgets are available through add-ons and allow for a more focused and topic-oriented research.\"\n    }), \"\\n\", _jsx(Figure, {\n      src: \"/images/features/prog/workflow_screenshot.thumb.png\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Interactive Data Exploration\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Orange widgets communicate with each other. They receive data on the input and send out filtered or processed data, models, or anything the widget does on the output. Say, start with a File widget that reads the data and connect its output to another widget, say, a Data Table, and you have a functioning workflow. Alter any change in one widget, the changes are instantaneously propagated through the downstream workflow. Changing a data file in the File widget will trigger the response in all downstream widgets. This is especially fun if the widgets are open and when you can immediately see the results of any changes in that data, parameters of the methods or selections in interactive visualizations. For example, in a simple workflow below, where selection of the data in the spreadsheet propagates to a scatter plot, which marks the selected data instances.\\n\", _jsx(_components.br, {}), \"\\n\", \"\\\\\"]\n    }), \"\\n\", _jsx(Figure, {\n      src: \"/images/features/prog/interactive-table-browser.thumb.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"\\\\\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Through the choice of the right widgets and their connections, it is easy to construct complex workflows for a broad variety of data analysis tasks.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Clever Workflow Design Interface\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Orange is easy to use even for complete novices. Start with the File widget and Orange will automatically suggest the next widgets that can be connected to it. For example, Orange knows you are likely to want Hierarchical Clustering after you've set up your Distances widget. All other defaults in the widgets are also set in a way that enables a simple analysis even without knowing a whole lot about statistics, machine learning, or exploratory data mining in general.\"\n    }), \"\\n\", _jsx(Figure, {\n      src: \"/images/features/prog/channel-completion.thumb.png\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}}]},"__N_SSG":true}