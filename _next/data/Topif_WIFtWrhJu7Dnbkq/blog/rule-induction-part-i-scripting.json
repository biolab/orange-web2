{"pageProps":{"frontmatter":{"author":"MATEVZKREN","date":"2016-08-05 11:52:39+00:00","draft":false,"title":"Rule Induction (Part I - Scripting)","blog":["classification","gsoc2016","orange3"],"post_format":["Quote"],"oldUrl":"/blog/2016/08/05/rule-induction-part-i-scripting/"},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    em: \"em\",\n    a: \"a\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.em, {\n        children: \"This is a guest blog from the Google Summer of Code project.\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"We’ve all heard the saying, “Rules are meant to be broken.” Regardless of how you might feel about the idea, one thing is certain. Rules must first be learnt. My 2016 \", _jsx(_components.a, {\n        href: \"https://summerofcode.withgoogle.com\",\n        children: \"Google Summer of Code\"\n      }), \" project revolves around doing just that. I am developing classification rule induction techniques for \", _jsx(_components.a, {\n        href: \"http://orange.biolab.si\",\n        children: \"Orange\"\n      }), \", and here describing the code currently available in the \", _jsx(_components.a, {\n        href: \"https://github.com/biolab/orange3/pull/1397\",\n        children: \"pull request\"\n      }), \" and that will become part of official distribution in an upcoming \", _jsx(_components.a, {\n        href: \"https://github.com/biolab/orange3/blob/master/CHANGELOG.md\",\n        children: \"release 3.3.8\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Rule induction from examples is recognised as a fundamental component of many machine learning systems. My goal was foremost to implement supervised rule induction algorithms and rule-based classification methods, but also to devise a more general framework of replaceable individual components that users could fine-tune to their needs. To this purpose, \", _jsx(_components.a, {\n        href: \"http://dx.doi.org/10.1023/A:1006524209794\",\n        children: \"separate-and-conquer strategy\"\n      }), \" was applied. In essence, learning instances are covered and removed following a chosen rule. The process is repeated while learning set examples remain. To evaluate found hypotheses and to choose the best rule in each iteration, search heuristics are used (primarily, rule class distribution is the decisive determinant).\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The use of the created module is straightforward. New rule induction algorithms can be easily introduced, by either utilising predefined components or developing new ones (these include various search algorithms, search strategies, evaluators, and others). Several well-known rule induction algorithms have already been included. Let’s see how they perform!\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.a, {\n        href: \"http://dx.doi.org/10.1023/A:1022641700528\",\n        children: \"Classic CN2\"\n      }), \" inducer constructs a list of ordered rules (decision list). Here, we load the \", _jsx(_components.em, {\n        children: \"titanic\"\n      }), \" data set and create a simple classifier, which can already be used to predict data.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" Orange\\ndata = Orange.data.Table(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'titanic'\"\n        }), \")\\nlearner = Orange.classification.CN2Learner()\\nclassifier = learner(data)\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Similarly, a set of unordered rules can be constructed using \", _jsx(_components.a, {\n        href: \"http://dx.doi.org/10.1007/BFb0017011\",\n        children: \"Unordered CN2\"\n      }), \" inducer. Rules are learnt for each class individually, in regard to the original learning data. To evaluate found hypotheses, Laplace accuracy measure is used. Having first initialised the learner, we then control the algorithm by modifying its parameters. The underlying components are available to us by accessing the rule finder.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [\"data = Table(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'iris.tab'\"\n        }), \")\\nlearner = CN2UnorderedLearner()\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# consider up to 10 solution streams at one time\"\n        }), \"\\nlearner.rule_finder.search_algorithm.beam_width = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"10\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# continuous value space is constrained to reduce computation time\"\n        }), \"\\nlearner.rule_finder.search_strategy.bound_continuous = \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"True\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# found rules must cover at least 15 examples\"\n        }), \"\\nlearner.rule_finder.general_validator.min_covered_examples = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"15\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# found rules must combine at most 2 selectors (conditions)\"\n        }), \"\\nlearner.rule_finder.general_validator.max_rule_length = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \"\\n\\nclassifier = learner(data)\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Induced rules can be quickly reviewed and interpreted. They are each of the form ‘\", _jsx(_components.em, {\n        children: \"if\"\n      }), \" cond \", _jsx(_components.em, {\n        children: \"then\"\n      }), \" predict class”. That is, a conjunction of selectors followed by the predicted class.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" rule \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" classifier.rule_list:\\n\", _jsx(_components.span, {\n          className: \"hljs-meta\",\n          children: \"... \"\n        }), _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"print\"\n        }), \"(rule, rule.curr_class_dist.tolist())\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-meta\",\n          children: \">>> \"\n        }), \"IF petal length<=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3.0\"\n        }), \" AND sepal width>=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2.9\"\n        }), \" THEN iris=Iris-setosa [\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"49\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"]\\n\", _jsx(_components.span, {\n          className: \"hljs-meta\",\n          children: \">>> \"\n        }), \"IF petal length>=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3.0\"\n        }), \" AND petal length<=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"4.8\"\n        }), \" THEN iris=Iris-versicolor [\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"46\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \"]\\n\", _jsx(_components.span, {\n          className: \"hljs-meta\",\n          children: \">>> \"\n        }), \"IF petal width>=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1.8\"\n        }), \" AND petal length>=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"4.9\"\n        }), \" THEN iris=Iris-virginica [\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"43\"\n        }), \"]\\n\", _jsx(_components.span, {\n          className: \"hljs-meta\",\n          children: \">>> \"\n        }), \"IF TRUE THEN iris=Iris-virginica [\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"50\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"50\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"50\"\n        }), \"]  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# the default rule\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If no other rules fire, default rule (majority classification) is used. Specific to each individual rule inducer, the application of the default rule varies.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Though rule learning is most frequently used in the context of predictive induction, it can be adapted to subgroup discovery. In contrast, subgroup discovery aims at learning individual patterns or interesting population subgroups, rather than to maximise classification accuracy. Induced rules prove very valuable in terms of their descriptive power. To this end, \", _jsx(_components.a, {\n        href: \"http://www.jmlr.org/papers/volume5/lavrac04a/lavrac04a.pdf\",\n        children: \"CN2-SD\"\n      }), \" algorithms were also implemented.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Hopefully, the addition to the Orange software suite will benefit both novice and expert users looking advance their knowledge in a particular area of study, through a better understanding of given predictions and underlying argumentation.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"thumbImage":null},"__N_SSG":true}