{"pageProps":{"frontmatter":{"author":"BIOLAB","date":"2011-09-01 23:48:00+00:00","draft":false,"title":"GSoC Review: MF - Matrix Factorization Techniques for Data Mining","blog":["gsoc","matrixfactorization"],"oldUrl":"/blog/2011/09/01/gsoc-review-mf-matrix-factorization-techniques-for-data-mining/"},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h3: \"h3\",\n    h4: \"h4\",\n    ul: \"ul\",\n    li: \"li\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    a: \"a\",\n    img: \"img\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"MF - Matrix Factorization Techniques for Data Mining is a Python scripting library which includes a number of published matrix factorization algorithms, initialization methods, quality and performance measures and facilitates the combination of these to produce new strategies. The library represents a unified and efficient interface to matrix factorization algorithms and methods.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The MF works with numpy dense matrices and scipy sparse matrices (where this is possible to save on space). The library has support for multiple runs of the algorithms which can be used for some quality measures. By setting runtime specific options tracking the residuals error within one (or more) run or tracking fitted factorization model is possible. Extensive documentation with working examples which demonstrate real applications, commonly used benchmark data and visualization methods are provided to help with the interpretation and comprehension of the results.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Content of Current Release\"\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"Factorization Methods\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"BD - Bayesian nonnegative matrix factorization Gibbs sampler [Schmidt2009]\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"BMF - Binary matrix factorization [Zhang2007]\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"ICM - Iterated conditional modes nonnegative matrix factorization [Schmidt2009]\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"LFNMF - Fisher nonnegative matrix factorization for learning local features [Wang2004], [Li2001]\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"LSNMF - Alternative nonnegative least squares matrix factorization using projected gradient method for subproblems [Lin2007]\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"NMF - Standard nonnegative matrix factorization with Euclidean / Kullback-Leibler update equations and Frobenius / divergence / connectivity cost functions [Lee2001], [Brunet2004]\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"NSNMF - Nonsmooth nonnegative matrix factorization [Montano2006]\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"PMF - Probabilistic nonnegative matrix factorization [Laurberg2008], [Hansen2008]\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"PSMF - Probabilistic sparse matrix factorization [Dueck2005], [Dueck2004], [Srebro2001], [Li2007]\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"SNMF - Sparse nonnegative matrix factorization based on alternating nonnegativity constrained least squares [Park2007]\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"SNMNMF - Sparse network regularized multiple nonnegative matrix factorization [Zhang2011]\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"Initialization Methods\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Random\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Fixed\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"NNDSVD [Boutsidis2007]\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Random C [Albright2006]\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Random VCol [Albright2006]\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"Quality and Performance Measures\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Distance\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Residuals\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Connectivity matrix\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Consensus matrix\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Entropy of the fitted NMF model [Park2007]\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Dominant basis components computation\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Explained variance\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Feature score computation representing its specificity to basis vectors [Park2007]\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Computation of most basis specific features for basis vectors [Park2007]\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Purity [Park2007]\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Residual sum of squares - can be used for rank estimate [Hutchins2008], [Frigyesi2008]\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Sparseness [Hoyer2004]\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Cophenetic correlation coefficient of consensus matrix - can be used for rank estimate [Brunet2004]\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Dispersion [Park2007]\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Factorization rank estimation\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Selected matrix factorization method specific\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Plans for Future\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"General plan for future releases of MF library is to alleviate the usage for non-technical users, increase library stability and provide comprehensive visualization methods. Specifically, in algorithm sense addition of the following could be provided.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Extending Bayesian methods with variational BD and linearly constrained BD.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Adaptation of the PMF model to interval-valued matrices.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Nonnegative matrix approximation. Multiplicative iterative schema.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Usage\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# Import MF library entry point for factorization\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" mf\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" scipy.sparse \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" csr_matrix\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" scipy \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" array\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" numpy \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" dot\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# We will try to factorize sparse matrix. Construct sparse matrix in CSR format.\"\n        }), \"\\nV = csr_matrix((array([\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \",\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \",\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \",\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"4\"\n        }), \",\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"5\"\n        }), \",\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"6\"\n        }), \"]),array([\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \",\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \",\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \",\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \",\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \",\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \"]),array([\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \",\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \",\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \",\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"6\"\n        }), \"])),shape=(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \",\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \"))\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# Run Standard NMF rank 4 algorithm\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# Returned object is fitted factorization model.\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# Through it user can access quality and performance measures.\"\n        }), \"\\nfit = mf.mf(V,method = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"nmf\\\"\"\n        }), \",max_iter = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"30\"\n        }), \",rank = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"4\"\n        }), \",update = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'divergence'\"\n        }), \",objective = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'div'\"\n        }), \")\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# Basis matrix. It is sparse, as input V was sparse as well.\"\n        }), \"\\nW = fit.basis()\\n\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"print\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Basis matrix\\\\n\\\"\"\n        }), \", W.todense()\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# Mixture matrix. We print this tiny matrix in dense format.\"\n        }), \"\\nH = fit.coef()\\n\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"print\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Coef\\\\n\\\"\"\n        }), \", H.todense()\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# Return the loss function according to Kullback-Leibler divergence.\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"print\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Distance Kullback-Leibler\\\"\"\n        }), \", fit.distance(metric = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"kl\\\"\"\n        }), \")\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# Compute generic set of measures to evaluate the quality of the factorization\"\n        }), \"\\nsm = fit.summary()\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# Print sparseness (Hoyer, 2004) of basis and mixture matrix\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"print\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Sparseness W: %5.3f  H: %5.3f\\\"\"\n        }), \" % (sm[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'sparseness'\"\n        }), \"][\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"], sm[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'sparseness'\"\n        }), \"][\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"])\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# Print actual number of iterations performed\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"print\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Iterations\\\"\"\n        }), \", sm[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'n_iter'\"\n        }), \"]\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# Print estimate of target matrix V\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"print\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Estimate\\\\n\\\"\"\n        }), \", dot(W.todense(), H.todense())\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Examples\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Examples with visualized results in bioinformatics, image processing, text analysis, recommendation systems are provided in \", _jsx(_components.a, {\n        href: \"http://helikoid.si/mf/\",\n        children: \"Examples section of Documentation.\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Figure 1: Reordered consensus matrix generated for rank = 2 on Leukemia data set.\"\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/blog/2011-09-gsoc-review-mf-matrix-factorization-techniques-for-data-mining/__optimized-images__/all_aml_consensus2.png__160x160_q95_crop.png\",\n      alt: \"\",\n      width: \"160\",\n      height: \"160\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Figure 2: Interpretation of NMF - Divergence basis vectors on Medlars data set. By considering the highest weighted terms in this vector, we can assign a label or topic to basis vector W1, a user might attach the label liver to basis vector W1.\"\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/blog/2011-09-gsoc-review-mf-matrix-factorization-techniques-for-data-mining/__optimized-images__/documents_basisw1.png__160x160_q95_crop.png\",\n      alt: \"\",\n      width: \"160\",\n      height: \"160\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Figure 3: Basis images of LSNMF obtained after 500 iterations on original face images. The bases trained by LSNMF are additive but not spatially localized for representation of faces.\"\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/blog/2011-09-gsoc-review-mf-matrix-factorization-techniques-for-data-mining/__optimized-images__/orl_faces_500_iters_large_lsnmf.png__160x160_q95_crop.png\",\n      alt: \"\",\n      width: \"160\",\n      height: \"160\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Relevant Links\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"http://helikoid.si/mf/\",\n          children: \"Extensive published documentation with examples\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"http://orange.biolab.si/trac/wiki/MatrixFactorization\",\n          children: \"Orange wiki MF Project page\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://github.com/marinkaz/mf\",\n          children: \"Github repository with source code\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"http://helikoid.si/mf/GSoC_MF.pdf\",\n          children: \"Short presentation in pdf format of MF library\"\n        })\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"thumbImage":null},"__N_SSG":true}