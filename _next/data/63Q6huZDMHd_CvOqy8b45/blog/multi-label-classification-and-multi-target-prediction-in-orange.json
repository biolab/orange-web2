{"pageProps":{"frontmatter":{"author":"BIOLAB","date":"2012-01-09 12:41:00+00:00","draft":false,"title":"Multi-label classification (and Multi-target prediction) in Orange","blog":["classification","gsoc","mlc","multilabel"],"oldUrl":"/blog/2012/01/09/multi-label-classification-and-multi-target-prediction-in-orange/"},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    pre: \"pre\",\n    code: \"code\",\n    strong: \"strong\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"The last summer, student Wencan Luo participated in \", _jsx(_components.a, {\n        href: \"https://code.google.com/soc/\",\n        children: \"Google Summer of Code\"\n      }), \" to implement \", _jsx(_components.a, {\n        href: \"/blog/2011/09/02/gsoc-review-multi-label-classification-implementation/\",\n        children: \"Multi-label Classification in Orange\"\n      }), \". He provided a framework, implemented a few algorithms and some prototype widgets. His work has been \\\"hidden\\\" in our repositories for too long; finally, we have merged part of his code into Orange (widgets are not there yet ...) and added a more general support for multi-target prediction.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"You can load multi-label tab-delimited data (e.g. \", _jsx(_components.a, {\n        href: \"http://orange.biolab.si/trac/intertrac/export%3Atrunk/orange/doc/datasets/emotions.tab\",\n        children: \"emotions.tab\"\n      }), \") just like any other \", _jsx(_components.a, {\n        href: \"/doc/reference/Orange.data.formats/#tab-delimited-format\",\n        children: \"tab-delimited data\"\n      }), \":\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"    >>> zoo = Orange.data.Table('zoo')            # single-target\\n    >>> emotions = Orange.data.Table('emotions')  # multi-label\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The difference is that now zoo's domain has a non-empty \", _jsx(_components.strong, {\n        children: \"class_var\"\n      }), \" field, while a list of \", _jsx(_components.strong, {\n        children: \"emotions\"\n      }), \"' labels can be obtained through it's domain's \", _jsx(_components.strong, {\n        children: \"class_vars\"\n      }), \":\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"    >>> zoo.domain.class_var\\n    EnumVariable 'type'\\n    >>> emotions.domain.class_vars\\n    <EnumVariable 'amazed-suprised',\\n     EnumVariable 'happy-pleased',\\n     EnumVariable 'relaxing-calm',\\n     EnumVariable 'quiet-still',\\n     EnumVariable 'sad-lonely',\\n     EnumVariable 'angry-aggresive'>\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"A simple example of a \", _jsx(_components.a, {\n        href: \"/doc/reference/Orange.multilabel/\",\n        children: \"multi-label classification\"\n      }), \" learner is a \\\"binary relevance\\\" learner. Let's try it out.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"    >>> learner = Orange.multilabel.BinaryRelevanceLearner()\\n    >>> classifier = learner(emotions)\\n    >>> classifier(emotions[0])\\n    [<orange.Value 'amazed-suprised'='0'>,\\n     <orange.Value 'happy-pleased'='0'>,\\n     <orange.Value 'relaxing-calm'='1'>,\\n     <orange.Value 'quiet-still'='1'>,\\n     <orange.Value 'sad-lonely'='1'>,\\n     <orange.Value 'angry-aggresive'='0'>]\\n    >>> classifier(emotions[0], Orange.classification.Classifier.GetProbabilities)\\n    [<1.000, 0.000>, <0.881, 0.119>, <0.000, 1.000>,\\n     <0.046, 0.954>, <0.000, 1.000>, <1.000, 0.000>]\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Real values of label variables of \", _jsx(_components.strong, {\n        children: \"emotions[0]\"\n      }), \" instance can be obtained by calling \", _jsx(_components.strong, {\n        children: \"emotions[0].get_classes()\"\n      }), \", which is analogous to the \", _jsx(_components.strong, {\n        children: \"get_class\"\n      }), \" method in the single-target case.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"For multi-label classification, we can also perform testing like usual, however, \", _jsx(_components.a, {\n        href: \"/doc/reference/Orange.evaluation.scoring/#scoring-for-multilabel-classification\",\n        children: \"specialised evaluation measures\"\n      }), \" have to be used:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"    >>> test = Orange.evaluation.testing.cross_validation([learner], emotions)\\n    >>> Orange.evaluation.scoring.mlc_hamming_loss(test)\\n    [0.2228780213603148]\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In one of the following blog posts, a multi-target regression method PLS that is in the process of implementation will be described.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"thumbImage":null},"__N_SSG":true}