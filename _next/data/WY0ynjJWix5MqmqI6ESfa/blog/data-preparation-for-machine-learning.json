{"pageProps":{"frontmatter":{"author":"AJDA","date":"2017-01-13 09:25:58+00:00","draft":false,"title":"Data Preparation for Machine Learning","blog":["analysis","business intelligence","data","feature engineering","preprocessing"],"oldUrl":"/blog/2017/01/13/data-preparation-for-machine-learning/"},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    strong: \"strong\",\n    img: \"img\",\n    a: \"a\",\n    ul: \"ul\",\n    li: \"li\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"We've said it numerous times and we're going to say it again. Data preparation is crucial for any data analysis. If your data is messy, there's no way you can make sense of it, let alone a computer. Computers are great at handling large, even enormous data sets, speedy computing and recognizing patterns. But they fail miserably if you give them the wrong input. Also some classification methods work better with binary values, other with continuous, so it is important to know how to treat your data properly.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Orange is well equipped for such tasks.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Widget no. 1: Preprocess\"\n      })\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/blog/2017-01-data-preparation-for-machine-learning/__webp-images__/preprocess.webp\",\n      alt: \"\",\n      width: \"205\",\n      height: \"95\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.a, {\n        href: \"/widget-catalog/data/preprocess/\",\n        children: \"Preprocess\"\n      }), \" is there to handle a big share of your preprocessing tasks.\"]\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/blog/2017-01-data-preparation-for-machine-learning/__webp-images__/original-data.webp\",\n      alt: \"\",\n      width: \"684\",\n      height: \"250\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"It can normalize numerical data variables. Say we have a fictional data set of people employed in your company. We want to know which employees are more likely to go on holiday, based on the yearly income, years employed in your company and total years of experience in the industry. If you plot this in heat map, you would see a bold yellow line at 'yearly income'. This obviously happens because yearly income has much higher values than years of experience or years employed by your company. You would naturally like the wage not to overweight the rest of the feature set, so normalization is the way to go. Normalization will transform your values to relative terms, that is, say (depending on the type of normalization) on a scale from 0 to 1. Now \", _jsx(_components.a, {\n            href: \"/widget-catalog/visualize/heatmap/\",\n            children: \"Heat Map\"\n          }), \" neatly shows that people who've been employed longer and have a higher wage more often go on holidays. (Yes, this is a totally fictional data set, but you see the point.)\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            align: \"center\",\n            children: _jsx(_components.img, {\n              src: \"/blog/2017-01-data-preparation-for-machine-learning/__webp-images__/heatmap1.webp\",\n              alt: \"\",\n              width: \"174\",\n              height: \"389\"\n            })\n          }), _jsx(_components.th, {\n            align: \"center\",\n            children: _jsx(_components.img, {\n              src: \"/blog/2017-01-data-preparation-for-machine-learning/__webp-images__/heatmap2.webp\",\n              alt: \"\",\n              width: \"178\",\n              height: \"396\"\n            })\n          })]\n        })\n      }), _jsx(_components.tbody, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            align: \"center\",\n            children: \"no normalization\"\n          }), _jsx(_components.td, {\n            align: \"center\",\n            children: \"normalized data\"\n          })]\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"It can impute missing values. Average or most frequent missing value imputation might seem as overly simple, but it actually works most of the time. Also, all the learners that require imputation do it implicitly, so the user doesn't have to configure yet another widget for that.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"If you want to compare your results against a randomly mixed data set, select 'Randomize' or if you want to select relevant features, this is the widget for it.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Preprocessing needs to be used with caution and understanding of your data to avoid losing important information or, worse, overfitting the model. A good example is a case of paramedics, who usually don't record pulse if it is normal. Missing values here thus cannot be imputed by an average value or random number, but as a distinct value (normal pulse). Domain knowledge is always crucial for data preparation.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Widget no. 2: Discretize\"\n      })\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/blog/2017-01-data-preparation-for-machine-learning/__webp-images__/discretize.webp\",\n      alt: \"\",\n      width: \"324\",\n      height: \"98\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"For certain tasks you might want to resort to binning, which is what \", _jsx(_components.a, {\n        href: \"/widget-catalog/data/discretize/\",\n        children: \"Discretize\"\n      }), \" does. It effectively distributes your continuous values into a selected number of bins, thus making the variable discrete-like. You can either discretize all your data variables at once, using selected discretization type, or select a particular discretization method for each attribute. The cool thing is the transformation is already displayed in the widget, so you instantly know what you're getting in the end. A good example of discretization would be having a data set of your customers with their age recorded. It would make little sense to segment customers by each particular age, so binning them into 4 age groups (young, young-adult, middle-aged, senior) would be a great solution. Also some visualizations require feature transformation - \", _jsx(_components.a, {\n        href: \"/widget-catalog/visualize/sievediagram/\",\n        children: \"Sieve Diagram\"\n      }), \" is currently one such widget. Mosaic Display, however, has the transformation already implemented internally.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.img, {\n        src: \"/blog/2017-01-data-preparation-for-machine-learning/__webp-images__/discretize1.webp\",\n        alt: \"\",\n        width: \"720\",\n        height: \"310\"\n      }), \"\\noriginal data\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.img, {\n        src: \"/blog/2017-01-data-preparation-for-machine-learning/__webp-images__/discretize2.webp\",\n        alt: \"\",\n        width: \"780\",\n        height: \"310\"\n      }), \"\\nDiscretized data with 'years employed' lower or higher then/equal to 8 (same for 'yearly income' and 'experience in the industry'.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Widget no. 3: Continuize\"\n      })\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/blog/2017-01-data-preparation-for-machine-learning/__webp-images__/continuize.webp\",\n      alt: \"\",\n      width: \"345\",\n      height: \"98\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This widget essentially creates new attributes out of your discrete ones. If you have, for example, an attribute with people's eye color, where values can be either blue, brown or green, you would probably want to have three separate attributes 'blue', 'green' and 'brown' with 0 or 1 if a person has that eye color. Some learners perform much better if data is transformed in such a way. You can also only have attributes where you would presume 0 is a normal condition and would only like to have deviations from the normal state recorded ('target or first value as base') or the normal state would be the most common value ('most frequent value as base'). \", _jsx(_components.a, {\n        href: \"/widget-catalog/data/continuize/\",\n        children: \"Continuize\"\n      }), \" widget offers you a lot of room to play. Best thing is to select a small data set with discrete values, connect it to Continuize and then further to \", _jsx(_components.a, {\n        href: \"/widget-catalog/data/datatable/\",\n        children: \"Data Table\"\n      }), \" and change the parameters. This is how you can observe the transformations in real time. It is useful for projecting discrete data points in \", _jsx(_components.a, {\n        href: \"/widget-catalog/visualize/linearprojection/\",\n        children: \"Linear Projection\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.img, {\n        src: \"/blog/2017-01-data-preparation-for-machine-learning/__webp-images__/continuize1.webp\",\n        alt: \"\",\n        width: \"420\",\n        height: \"312\"\n      }), \"\\nOriginal data.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.img, {\n        src: \"/blog/2017-01-data-preparation-for-machine-learning/__webp-images__/continuize2.webp\",\n        alt: \"\",\n        width: \"643\",\n        height: \"311\"\n      }), \"\\nContinuized data with two new columns - attribute 'position' was replaced by attributes 'position=office worker' and 'position=technical staff' (same for 'gender').\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Widget no. 4: Purge Domain\"\n      })\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/blog/2017-01-data-preparation-for-machine-learning/__webp-images__/purge.webp\",\n      alt: \"\",\n      width: \"189\",\n      height: \"90\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Get a broom and sort your data! That's what \", _jsx(_components.a, {\n        href: \"/widget-catalog/data/purgedomain/\",\n        children: \"Purge Domain\"\n      }), \" does. If all of the values of some attributes are constant, it will remove these attributes. If you have unused (empty) attributes in your data, it will remove them. Effectively, you will get a nice and comprehensive data set in the end.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.img, {\n        src: \"/blog/2017-01-data-preparation-for-machine-learning/__webp-images__/purge1.webp\",\n        alt: \"\",\n        width: \"893\",\n        height: \"94\"\n      }), \"\\nOriginal data.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.img, {\n        src: \"/blog/2017-01-data-preparation-for-machine-learning/__webp-images__/purge2.webp\",\n        alt: \"\",\n        width: \"401\",\n        height: \"94\"\n      }), \"\\nEmpty columns and columns with the same (constant) value were removed.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Of course, don't forget to include all these procedures into your report with the 'Report' button! :)\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}