{"pageProps":{"frontmatter":{"author":"AJDA","date":"2015-07-10 07:00:54+00:00","draft":false,"title":"Learn with Paint Data","type":"blog","blog":["classification","clustering","data","examples","plot","visualization"]},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    strong: \"strong\",\n    img: \"img\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Paint Data\"\n      }), \" widget might initially look like a kids’ game, but in combination with other Orange widgets it becomes a very simple and useful tool for conveying statistical concepts, such as \", _jsx(_components.strong, {\n        children: \"k-means\"\n      }), \", \", _jsx(_components.strong, {\n        children: \"hierarchical clustering\"\n      }), \" and \", _jsx(_components.strong, {\n        children: \"prediction models\"\n      }), \" (like SVM, logistical regression, etc.).\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The widget enables you to draw your data on a 2-D plane. You can name the x and y axes, select the number of classes (which are represented by different colors) and then position the points on a graph.\"\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/blog/2015-07-learn-with-paint-data/PaintData-Example.webp\",\n      alt: \"\",\n      width: \"803\",\n      height: \"626\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Several painting tools allow you to manage your data set according to your specific needs; brush will paint several data instances at once, while put allows you paint a single data instance. Select a data subset and view it in the Data Table widget or zoom in to see the position of your points up close. Jitter and magnet are converse tools which allow either to spread the instances or draw them closer together.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The data will be represented in a data table with two attributes, where their instances correspond to coordinates in the system. Such data set is great for demonstrating k-means and hierarchical clustering methods. Just like we do below. In the screenshot we see that k-means, with our particular settings, recognizes clusters way better than hierarchical clustering. It returns a score rank, where the best score (the one with the highest value) means the most likely number of clusters. Hierarchical clustering, however, doesn’t even group the right classes together.\"\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/blog/2015-07-learn-with-paint-data/PaintData-k-means1.webp\",\n      alt: \"\",\n      width: \"1600\",\n      height: \"1280\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Paint Data widget for comparing precision of k-means and hierarchical clustering methods.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Another way to use \", _jsx(_components.strong, {\n        children: \"Paint Data\"\n      }), \" is to observe the performance of classification methods, where we can alter the graph to demonstrate improvement or deterioration of prediction models. By painting the data points we can try to construct the data set, which would be difficult for one but easy for another classifier. Say, why does linear SVM fail on the data set below?\"]\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/blog/2015-07-learn-with-paint-data/PaintData-TestLearners.webp\",\n      alt: \"\",\n      width: \"1200\",\n      height: \"960\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Use Paint Data to compare prediction quality of several classifiers.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Happy painting!\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}